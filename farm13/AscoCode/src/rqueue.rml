type ('prio, 'a) queue =
  | Empty
  | Node of 'prio * 'a * ('prio, 'a) queue * ('prio, 'a) queue

let rec push queue (delay, elt) =
  match queue with
  | Empty -> Node(delay, elt, Empty, Empty)
  | Node(d, e, left, right) ->
      if delay <= d
      then Node(delay, elt, push right (d, e), left)
      else Node(d, e, push right (delay, elt), left)

exception Queue_is_empty

let rec remove_top = function
  | Empty -> raise Queue_is_empty
  | Node(delay, elt, left, Empty) -> left
  | Node(delay, elt, Empty, right) -> right
  | Node(delay, elt, (Node(ldelay, lelt, _, _) as left),
         (Node(rdelay, relt, _, _) as right)) ->
           if ldelay <= rdelay
           then Node(ldelay, lelt, remove_top left, right)
           else Node(rdelay, relt, left, remove_top right)

let pop = function
  | Empty -> None
  | Node(delay, elt, _, _) as queue -> Some(delay, elt, remove_top queue)

type ('prio, 'a) action =
  | Push of 'prio * 'a
  | Remove
  | Sustain of ('prio, 'a) queue

type ('prio,'a) kind =
  | Not_yet of (('prio * 'a) list * int * ('prio,'a) queue option)
  | Current of ('prio,'a) queue


type ('prio, 'a) body = {mutable state : ('prio, 'a) kind}

type ('prio, 'a) state = ('prio, 'a) body option

let rec fold f n acc =
  match n with
  | 0 -> acc
  | _ -> fold f (n-1) (f acc)

let apply_actions ads rms q =
  match q with
  | None -> assert false
  | Some q ->
      let q' = fold remove_top rms q in
      List.fold_left (fun q  x -> push q x) q' ads


let add_action x st =
  match x with
  | Remove ->
      begin match st with
      | Not_yet (ads, rms, q) -> Not_yet (ads, rms + 1, q)
      | Current q -> assert false
      end
  | Push e ->
      begin match st with
      | Not_yet (ads, rms, q) -> Not_yet (e::ads, rms, q)
      | Current q -> assert false
      end
  | Sustain q ->
      begin match st with
      | Not_yet (ads, rms, None) -> Not_yet (ads, rms, Some q)
      | Not_yet (ads, rms, Some _) -> assert false
      | Current q -> assert false
      end


let get_last st =
  match (last ?st) with
  | None -> assert false
  | Some st' ->
      begin match st'.state with
      | Current q -> q
      | Not_yet(ads, rms, q) ->
	  let q' = apply_actions ads rms q in
	  st'.state <- Current q';
	  q'
      end

let make_queue () =
  let combine x st =
    match st with
    | None ->
	let st' = {state = add_action x (Not_yet ([],0,None))} in
	Some st'
    | Some st' ->
	st'.state <- add_action x st'.state;
	Some st'
  in
  signal state default None gather combine in
  let process hold  =
    emit state (Sustain Empty);
    loop
      pause;
      await immediate state;
      let q = get_last state in
      emit state (Sustain q) ;
    end
  in

  let push v =
    emit state (Push v)
  in

  let pop d =
    let qq = get_last state in
    let rec aux l qq =
      match qq with
      | Empty -> l
      | _ ->
	  begin match pop qq with
	  | None -> l
	  | Some(d', s', qq') ->
	      if d >= d' then
	        (emit state Remove; aux ((d', s')::l) qq')
	      else l
	  end
    in
    aux [] qq
  in

  hold, push, pop


let process runtime deadline sending adding =
  let process send queue_pop =
    pause;
    loop
      await immediate one deadline (d) in
      let p = queue_pop (d) in
      sending d p;
      pause
    end
  in

  let process update queue_push =
    loop
      await adding (v) in
      List.iter (fun x -> queue_push x) v;
    end
  in

  let queue, queue_push, queue_pop = make_queue () in
  run queue ||
  run (send queue_pop) ||
  run (update queue_push)
