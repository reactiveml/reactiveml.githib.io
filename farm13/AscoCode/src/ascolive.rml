open Types
open Parser
open Lexer
open Network

(* Parse the score and simulation files *)
let parse file p =
  let f = open_in file in
  let buf = Lexing.from_channel f in
  try
      let res = p Lexer.make_token buf in
      close_in f;
      res
  with
    Lexer.Lexing_error s ->
      Utils.localisation (Lexing.lexeme_start_p buf) file;
      prerr_endline ("Syntax error: "^file);
      exit 1
  | Parsing.Parse_error ->
      Utils.localisation (Lexing.lexeme_start_p buf) file;
      prerr_endline ("Syntax error: "^file);
      exit 1

let parse_score s = parse s Parser.make_score

type env =
    { instr_score : instr_score;
      event_handler : unit process;
      scheduler : unit process;
      wait : delay -> unit process;
      wait_event : label -> status process;
      listen : (instr_event, instr_event list) event;
      date : (delay, delay list) event;
      perf : (perf_elem, perf_elem list) event;
      freq : float;
      client_port : int;
      server_port : int; }

let create_env instr_score freq client_port server_port =
  signal listen  in
  signal date in
  signal perf in
  (* let n = Array.length instr_score in *)
  (* let events = Array.init (n+1) (fun i -> signal s in s) in *)
  let scheduler, wait = Time.make_scheduler date in
  let event_handler, wait_event = Input.make_handler listen in
  let env =
    { instr_score = instr_score;
      event_handler = event_handler;
      scheduler = scheduler;
      wait = wait;
      wait_event = wait_event;
      listen = listen;
      date = date;
      perf = perf;
      freq = freq;
      client_port = client_port;
      server_port = server_port; } in
  env

let process init_env env =
  emit env.listen {index = 0; bps = ( 120. /. 60.)};
  pause

let process live env =
  run (Time.metronome env.listen env.freq env.date) ||
  run env.event_handler ||
  run env.scheduler ||
  run (Input.udp env.server_port env.listen) ||
  run (Output.udp env.client_port env.perf)


let tight = Tight
let loose = Loose
let partial = Partial
let causal = Causal
let global = Global
let local = Local


let max_note d n =
  let s = "mnote "^(string_of_int n)^" 127" in
  d, Action(Message s)

let asco_signal s =
  Action (Signal s)

let sequence_duration seq =
  List.fold_left (fun d (dae,ae) -> d +. dae) 0.0 seq

let asco_group synchro error seq =
  Group({group_synchro = synchro;
	 group_error = error;
	 group_seq = seq;})

let process exec se env =
  let play_score =
    Motor.make_player env.instr_score env.wait env.wait_event env.perf
  in
  await immediate one env.listen (ev) in
  run (play_score [se] ev.index)

let process exec_group i delta g env =
  let se =  {event = i;
	     seq = [delta,g]} in
  run (exec se env)

let process exec_loop n i delta g env =
  match g with
  | Group(g') ->
      let period = sequence_duration g'.group_seq in
      for cpt = 0 to (n-1) do
	let c = float_of_int cpt in
	let d = delta +. c *. period in
	let j = Utils.last_one env.listen in
	run (exec_group i d g env);
	pause
      done
  | _ -> assert false

(*Chord parameter (major or minor)*)
type color = Maj | Min

type note =
  | A2 | A3 | A4
  | A2' | A3' | A4'
  | B2 | B3 | B4
  | C2 | C3 | C4
  | C2' | C3' | C4'
  | D2 | D3 | D4
  | D2' | D3' | D4'
  | E2 | E3 | E4
  | F2 | F3 | F4
  | F2' | F3' | F4'
  | G2 | G3 | G4
  | G2' | G3' | G4'


let note_to_midi note =
  match note with
  | A2 -> 45 | A3 -> 57 | A4 -> 69
  | A2' -> 46 | A3' -> 58 | A4' -> 70
  | B2 -> 47 | B3 -> 59 | B4 -> 71
  | C2 -> 48 | C3 -> 60 | C4 -> 72
  | C2' -> 49 | C3' -> 61 | C4' -> 73
  | D2 -> 50 | D3 -> 62 | D4 -> 74
  | D2' -> 51 | D3' -> 63 | D4' -> 75
  | E2 -> 52 | E3 -> 64 | E4 -> 76
  | F2 -> 53 | F3 -> 65 | F4 -> 77
  | F2' -> 54 | F3' -> 66 | F4' -> 78
  | G2 -> 55 | G3 -> 67 | G4 -> 79
  | G2' -> 56 | G3' -> 68 | G4' -> 80
