open Types
open Parser
open Lexer
open Network

(* Parse the score and simulation files *)
let parse file p =
  let f = open_in file in
  let buf = Lexing.from_channel f in
  try
      let res = p Lexer.make_token buf in
      close_in f;
      res
  with
    Lexer.Lexing_error s ->
      Utils.localisation (Lexing.lexeme_start_p buf) file;
      prerr_endline ("Syntax error: "^file);
      exit 1
  | Parsing.Parse_error ->
      Utils.localisation (Lexing.lexeme_start_p buf) file;
      prerr_endline ("Syntax error: "^file);
      exit 1

let parse_score s = parse s Parser.make_score

type env =
    { instr_score : instr_score;
      runtime : unit process;
      wait : delay -> unit process;
      wait_event : label -> status process;
      listen : (instr_event, instr_event list) event;
      date : (delay, delay list) event;
      freq : float;
      perf : (perf_elem, perf_elem list) event;
      client_port : int;
      server_port : int; }

let create_env instr_score freq client_port server_port =
  signal listen in
  signal date in
  signal perf in
  (* let n = Array.length instr_score in *)
  (* let events = Array.init (n+1) (fun i -> signal s in s) in *)
  let scheduler, wait = Time.make_scheduler date in
  let event_handler, wait_event = Input.make_handler listen in
  let process runtime =
    run (Time.metronome listen freq date) ||
    run event_handler ||
    run scheduler
  in
  let env =
    { instr_score = instr_score;
      runtime = runtime;
      wait = wait;
      wait_event = wait_event;
      listen = listen;
      date = date;
      perf = perf;
      freq = freq;
      client_port = client_port;
      server_port = server_port; } in
  env

let process init_env env =
  emit env.listen {index = 0; bps = ( 120. /. 60.)};
  pause

let process live env =
  run env.runtime ||
  run (Input.udp env.server_port env.listen) ||
  run (Output.udp env.client_port env.perf)


let tight = Tight
let loose = Loose
let partial = Partial
let causal = Causal
let global = Global
let local = Local


let max_note d n =
  let s = "mnote "^(string_of_int n)^" 127" in
  d, Action(Message s)

let asco_signal s =
  Action (Signal s)

let sequence_duration seq =
  List.fold_left (fun d (dae,ae) -> d +. dae) 0.0 seq

let asco_group synchro error seq =
  Group({group_synchro = synchro;
	 group_error = error;
	 group_seq = seq;})

let process exec se env =
  let play_score =
    Motor.make_player env.instr_score env.wait env.wait_event env.perf
  in
  await immediate one env.listen (ev) in
  run (play_score [se] ev.index)

let process exec_group i delta g env =
  let se =  {event = i;
	     seq = [delta,g]} in
  run (exec se env)

let process exec_loop n i delta g env =
  match g with
  | Group(g') ->
      let j = (Utils.last_one env.listen).index + 1 in
      let di = env.instr_score.(i) in
      let dj = env.instr_score.(j) in
      let period = sequence_duration g'.group_seq in
      let process looop n i delta g =
	for cpt = 0 to (n-1) do
	  let c = float_of_int cpt in
	  let d = delta +. c *. period in
	  run (exec_group i d g env);
	  pause
	done
      in
      if di >= dj then
	run (looop n i delta g)
      else
	let n' = int_of_float ((dj -. di -. delta) /. period) in
	print_int n';
	print_newline ();
	let nf' = float_of_int n' in
	run (looop (n - n') i (delta +. nf' *. period)  g)
  | _ -> assert false

(*Chord parameter (major or minor)*)
type color = Maj | Min

type note =
  | A2 | A3 | A4
  | A2d | A3d | A4d
  | B2 | B3 | B4
  | C2 | C3 | C4
  | C2d | C3d | C4d
  | D2 | D3 | D4
  | D2d | D3d | D4d
  | E2 | E3 | E4
  | F2 | F3 | F4
  | F2d | F3d | F4d
  | G2 | G3 | G4
  | G2d | G3d | G4d


let note_to_midi note =
  match note with
  | A2 -> 45 | A3 -> 57 | A4 -> 69
  | A2d -> 46 | A3d -> 58 | A4d -> 70
  | B2 -> 47 | B3 -> 59 | B4 -> 71
  | C2 -> 48 | C3 -> 60 | C4 -> 72
  | C2d -> 49 | C3d -> 61 | C4d -> 73
  | D2 -> 50 | D3 -> 62 | D4 -> 74
  | D2d -> 51 | D3d -> 63 | D4d -> 75
  | E2 -> 52 | E3 -> 64 | E4 -> 76
  | F2 -> 53 | F3 -> 65 | F4 -> 77
  | F2d -> 54 | F3d -> 66 | F4d -> 78
  | G2 -> 55 | G3 -> 67 | G4 -> 79
  | G2d -> 56 | G3d -> 68 | G4d -> 80
