open Types
open Parser
open Lexer
open Network

(* Parse the score and simulation files *)
let parse file p =
  let f = open_in file in
  let buf = Lexing.from_channel f in
  try
      let res = p Lexer.make_token buf in
      close_in f;
      res
  with
    Lexer.Lexing_error s ->
      Utils.localisation (Lexing.lexeme_start_p buf) file;
      prerr_endline ("Syntax error: "^file);
      exit 1
  | Parsing.Parse_error ->
      Utils.localisation (Lexing.lexeme_start_p buf) file;
      prerr_endline ("Syntax error: "^file);
      exit 1

let parse_score s = parse s Parser.make_score

let make_instr_score () =
  let hold,add,remove,find,nearest = Rmap.make_map () in
  let instr_score =
    { nearest = nearest;
      find = find;
      remove = remove;
      add = add; } in
  hold, instr_score

type env =
    { instr_score : instr_score_map;
      player : score_event list -> unit process;
      wait : delay -> unit process;
      listen : (instr_event, instr_event list) event;
      date : (delay, delay list) event;
      perf : (perf_elem, perf_elem list) event; }

let create_env freq =
  signal listen in
  signal date in
  signal perf in
  let action_scheduler, wait = Time.make_action_scheduler date in
  let event_scheduler, wait_event = Input.make_event_scheduler listen in
  let hold_instr_score, instr_score = make_instr_score () in

  let process runtime =
    run hold_instr_score ||
    run (Time.metronome listen freq date) ||
    run event_scheduler ||
    run action_scheduler
  in

  let process player score =
    let play_score =
      Motor.make_player instr_score wait wait_event perf
    in
    await immediate one listen (ev) in
    run (play_score score ev.index)
  in


  let env =
    { instr_score = instr_score;
      player = player;
      wait = wait;
      listen = listen;
      date = date;
      perf = perf; } in
  runtime, env

let process init_env tempo env =
  emit env.listen {index = 0; bps = ( tempo /. 60.)};
  pause

let process load_instr_score isc env =
  Array.iteri (fun i d -> env.instr_score.add (i,d)) isc;
  pause

let process live in_port out_port runtime env =
  run (Input.udp in_port env.listen) ||
  run runtime ||
  run (Output.udp out_port env.perf)

let asco_note d n =
  let s = "mnote "^(string_of_int n)^" 127" in
  d, Action(Message s)

let asco_signal s =
  Action (Signal s)

let asco_group synchro error seq =
  Group({group_synchro = synchro;
	 group_error = error;
	 group_seq = seq;})

let asco_score_event i seq =
  { event = i;
    seq = seq; }

let process exec_score score env =
  run (env.player score)

let process exec_score_event se env =
  run (exec_score [se] env)

let process exec_group i delta g env =
  let se =  {event = i;
	     seq = [delta,g]} in
  run (exec_score_event se env)

let sequence_duration seq =
  List.fold_left (fun d (dae,ae) -> d +. dae) 0.0 seq

let process exec_loop n i delta g env =
  match g with
  | Group(g') ->
      let j = (Utils.last_one env.listen).index + 1 in
      let di = env.instr_score.find i in
      let dj = env.instr_score.find j in
      let period = sequence_duration g'.group_seq in
      let process looop n i delta g =
	for cpt = 0 to (n-1) do
	  let c = float_of_int cpt in
	  let d = delta +. c *. period in
	  run (exec_group i d g env);
	  pause
	done
      in
      if di >= dj then
	run (looop n i delta g)
      else
	let n' = int_of_float ((dj -. di -. delta) /. period) in
	let nf' = float_of_int n' in
	run (looop (n - n') i (delta +. nf' *. period)  g)
  | _ -> assert false

(*Chord parameter (major or minor)*)

let tight = Tight
let loose = Loose
let partial = Partial
let causal = Causal
let global = Global
let local = Local



type color = Maj | Min

type note =
  | A2 | A3 | A4
  | A2d | A3d | A4d
  | B2 | B3 | B4
  | C2 | C3 | C4
  | C2d | C3d | C4d
  | D2 | D3 | D4
  | D2d | D3d | D4d
  | E2 | E3 | E4
  | F2 | F3 | F4
  | F2d | F3d | F4d
  | G2 | G3 | G4
  | G2d | G3d | G4d


let note_to_midi note =
  match note with
  | A2 -> 45 | A3 -> 57 | A4 -> 69
  | A2d -> 46 | A3d -> 58 | A4d -> 70
  | B2 -> 47 | B3 -> 59 | B4 -> 71
  | C2 -> 48 | C3 -> 60 | C4 -> 72
  | C2d -> 49 | C3d -> 61 | C4d -> 73
  | D2 -> 50 | D3 -> 62 | D4 -> 74
  | D2d -> 51 | D3d -> 63 | D4d -> 75
  | E2 -> 52 | E3 -> 64 | E4 -> 76
  | F2 -> 53 | F3 -> 65 | F4 -> 77
  | F2d -> 54 | F3d -> 66 | F4d -> 78
  | G2 -> 55 | G3 -> 67 | G4 -> 79
  | G2d -> 56 | G3d -> 68 | G4d -> 80
