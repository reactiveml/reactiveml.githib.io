open Types
open Reactive_map
open Parser
open Lexer
open Network

(* Parse the score and simulation files *)
let parse file p =
  let f = open_in file in
  let buf = Lexing.from_channel f in
  try
      let res = p Lexer.make_token buf in
      close_in f;
      res
  with
    Lexer.Lexing_error s ->
      Utils.localisation (Lexing.lexeme_start_p buf) file;
      prerr_endline ("Syntax error: "^file);
      exit 1
  | Parsing.Parse_error ->
      Utils.localisation (Lexing.lexeme_start_p buf) file;
      prerr_endline ("Syntax error: "^file);
      exit 1

let parse_score s = parse s Parser.make_score
let parse_simu s = parse s Parser.make_simu


type env =
    { instr_score : (label, delay) rmap;
      player : score -> unit process;
      wait : delay -> unit process;
      listen : (instr_event, instr_event list) event;
      date : (delay, delay list) event;
      perf : (perf_elem, perf_elem list) event; }

let create_env freq =
  signal listen in
  signal date in
  signal perf in
  let action_scheduler, wait = Time.make_action_scheduler date in
  let event_scheduler, wait_event = Input.make_event_scheduler listen in
  let hold_instr_score, instr_score = make_map () in

  let process runtime =
    run hold_instr_score ||
    run (Time.metronome listen freq date) ||
    run event_scheduler ||
    run action_scheduler
  in

  let process player score =
    let play_score =
      Motor.make_player instr_score wait wait_event perf
    in
    await immediate one listen (ev) in
    run (play_score score ev.index)
  in

  let env =
    { instr_score = instr_score;
      player = player;
      wait = wait;
      listen = listen;
      date = date;
      perf = perf; } in
  runtime, env

let process init_env tempo env =
  emit env.listen {index = 0; bps = ( tempo /. 60.)};
  pause

let process load_instr_score isc env =
  let rec aux i l =
    match l with
    | [] -> ()
    | h::t ->
	begin
	  env.instr_score.add (i,h);
	  aux (i + 1) t
	end
  in
  aux 1 isc;
  pause

let process live in_port out_port runtime env =
  run (Input.udp in_port env.listen) ||
  run runtime ||
  run (Output.udp out_port env.perf) (* || *)
  (* run (Utils.verbose env.listen env.perf) *)



let tight = Tight
let loose = Loose
let partial = Partial
let causal = Causal
let global = Global
let local = Local

let note n =
  let s = "mnote "^(string_of_int n)^" 127" in
  Action(Message s)

let rml_signal s =
  Action (Signal s)

let group synchro error seq =
  Group({group_synchro = synchro;
	 group_error = error;
	 group_seq = seq;})

let score_event i seq =
  { event = i;
    seq = seq; }

let (>>) s1 s2 = s1 @ s2

let (//) s1 s2 =
  let g1 = group loose partial s1 in
  let g2 = group loose partial s2 in
  [0.0, g1; 0.0, g2]


let process exec_sequence sequence env =
  let rec process play s delta =
    match s with
    | [] -> ()
    | (d,ae)::s' ->
	let dn = d +. delta in
	run (env.wait d);
	begin match ae with
	| Action(a) ->
	    emit env.perf (-1,d,a);
	    run (play s' dn)
	| Group(g) ->
	    (run (play g.group_seq dn) ||
	    run (play s' dn))
	| Until(u) ->
	    begin
	      do
		run (play u.until_seq dn)
	      until env.listen ([ev]) when (ev.index = u.until_event) done
              ||
	      run (play s' dn)
	    end
	end
  in
  run (play sequence 0.0)

let process exec_asco_sequence i sequence env =
  let se =
    { event = i;
      seq = sequence; }
  in
  run (env.player [se])

let process exec_group delta g env =
  let s = [delta,g] in
  run (exec_sequence s env)

let process exec_asco_group i delta g env =
  let s = [delta,g] in
  run (exec_asco_sequence i s env)

let sequence_duration seq =
  List.fold_left (fun d (dae,ae) -> d +. dae) 0.0 seq

let process exec_loop n delta g env =
  match g with
  | Group(g') ->
      let period = sequence_duration g'.group_seq in
      for cpt = 0 to (n-1) do
	let c = float_of_int cpt in
	let d = delta +. c *. period in
	run (exec_group d g env);
	pause
      done
  | _ -> assert false

let process exec_asco_loop n i delta g env =
  match g with
  | Group(g') ->
      let j = (Utils.last_one env.listen).index + 1 in
      let di = env.instr_score.find i in
      let dj = env.instr_score.find j in
      let period = sequence_duration g'.group_seq in
      let process looop n i delta g =
	for cpt = 0 to (n-1) do
	  let c = float_of_int cpt in
	  let d = delta +. c *. period in
	  run (exec_asco_group i d g env);
	  pause
	done
      in
      if di >= dj then
	run (looop n i delta g)
      else
	let n' = int_of_float ((dj -. di -. delta) /. period) in
	let nf' = float_of_int n' in
	run (looop (n - n') i (delta +. nf' *. period)  g)
  | _ -> assert false

(*Chord parameter (major or minor)*)
type color = Maj | Min

type note =
  | A2 | A3 | A4
  | A2d | A3d | A4d
  | B2 | B3 | B4
  | C2 | C3 | C4
  | C2d | C3d | C4d
  | D2 | D3 | D4
  | D2d | D3d | D4d
  | E2 | E3 | E4
  | F2 | F3 | F4
  | F2d | F3d | F4d
  | G2 | G3 | G4
  | G2d | G3d | G4d


let note_to_midi note =
  match note with
  | A2 -> 45 | A3 -> 57 | A4 -> 69
  | A2d -> 46 | A3d -> 58 | A4d -> 70
  | B2 -> 47 | B3 -> 59 | B4 -> 71
  | C2 -> 48 | C3 -> 60 | C4 -> 72
  | C2d -> 49 | C3d -> 61 | C4d -> 73
  | D2 -> 50 | D3 -> 62 | D4 -> 74
  | D2d -> 51 | D3d -> 63 | D4d -> 75
  | E2 -> 52 | E3 -> 64 | E4 -> 76
  | F2 -> 53 | F3 -> 65 | F4 -> 77
  | F2d -> 54 | F3d -> 66 | F4d -> 78
  | G2 -> 55 | G3 -> 67 | G4 -> 79
  | G2d -> 56 | G3d -> 68 | G4d -> 80
