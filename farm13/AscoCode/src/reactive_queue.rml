open Caml_queue

type ('prio, 'a) action =
  | Push of 'prio * 'a
  | Remove
  | Sustain of ('prio, 'a) queue

type ('prio,'a) kind =
  | Not_yet of (('prio * 'a) list * int * ('prio,'a) queue option)
  | Current of ('prio,'a) queue


type ('prio, 'a) body = {mutable state : ('prio, 'a) kind}

type ('prio, 'a) state = ('prio, 'a) body option

let rec fold f n acc =
  match n with
  | 0 -> acc
  | _ -> fold f (n-1) (f acc)

let apply_actions ads rms q =
  match q with
  | None -> assert false
  | Some q ->
      let q' = fold remove_top rms q in
      List.fold_left (fun q  x -> push q x) q' ads


let add_action x st =
  match x with
  | Remove ->
      begin match st with
      | Not_yet (ads, rms, q) -> Not_yet (ads, rms + 1, q)
      | Current q -> assert false
      end
  | Push e ->
      begin match st with
      | Not_yet (ads, rms, q) -> Not_yet (e::ads, rms, q)
      | Current q -> assert false
      end
  | Sustain q ->
      begin match st with
      | Not_yet (ads, rms, None) -> Not_yet (ads, rms, Some q)
      | Not_yet (ads, rms, Some _) -> assert false
      | Current q -> assert false
      end


let get_last st =
  match (last ?st) with
  | None -> assert false
  | Some st' ->
      begin match st'.state with
      | Current q -> q
      | Not_yet(ads, rms, q) ->
	  let q' = apply_actions ads rms q in
	  st'.state <- Current q';
	  q'
      end

type ('prio, 'a) rqueue =
    { push : 'prio * 'a -> unit;
      pop : 'prio -> ('prio * 'a) list; }

let make_queue () =
  let combine x st =
    match st with
    | None ->
	let st' = {state = add_action x (Not_yet ([],0,None))} in
	Some st'
    | Some st' ->
	st'.state <- add_action x st'.state;
	Some st'
  in
  signal state default None gather combine in
  let process hold  =
    emit state (Sustain empty);
    loop
      pause;
      await immediate state;
      let q = get_last state in
      emit state (Sustain q) ;
    end
  in

  let push v =
    emit state (Push v)
  in

  let pop d =
    let qq = get_last state in
    let rec aux l qq =
      if is_empty qq then l
      else
	begin match pop qq with
	| None -> l
	| Some(d', s', qq') ->
	    if d >= d' then
	      (emit state Remove; aux ((d', s')::l) qq')
	    else l
	end
    in
    aux [] qq
  in

  hold,
  {push = push;
   pop = pop; }



let process runtime deadline sending adding =
  let process send queue_pop =
    pause;
    loop
      await immediate one deadline (d) in
      let p = queue_pop (d) in
      sending d p;
      pause
    end
  in

  let process update queue_push =
    loop
      await adding (v) in
      List.iter (fun x -> queue_push x) v;
    end
  in

  let hold, queue = make_queue () in
  run hold ||
  run (send queue.pop) ||
  run (update queue.push)
