(***************************************************************)
(*                        Reactive Asco                        *)
(*                                                             *)
(*                                                             *)
(* Implement the wait process (relative to the tempo)          *)
(* This is an optimized version using a priority queue.        *)
(***************************************************************)

open Types
open Utils

(* Generate a regular real-time signal ck of frequence freq. *)
let process emit_clock clock freq  =
  let period = 1. /. freq in
  let next = ref (Unix.gettimeofday () +. period) in
  loop
    let current = Unix.gettimeofday () in
    if (current >= !next)
    then
      begin
	emit clock ();
	next := !next +. period
      end;
    pause
  end


(* Compute the delay, relative to the tempo, elapsed since the
   beginning of its execution.
*)
let process elapsed listen clock freq date =
  let period = 1. /. freq in
  let m = ref 0.0 in
  do
    loop
      let ev = last_one listen in
      m := !m +. ev.bps *. period;
      emit date !m;
      pause;
    end
  when clock done

(* Wait a delay 'dur' relatively to the tempo. The waiting process is
   realized by the scheduler. Thereofore to achieve the desired
   behavior we just need to register on the scheduler queue with the
   'queue' signal. 'date' is the current value of 'elapsed'.
*)
let process wait date adding dur =
  signal s in
  await immediate one date(e) in
  emit adding ((dur +. e),s);
  await immediate s

(* Run the processes tick and elapsed and return date *)
let process metronome listen freq date =
  signal clock in
  run (emit_clock clock freq) ||
  run (elapsed listen clock freq date)


let process metronome listen freq date =
  signal clock in
  run (emit_clock clock freq) ||
  run (elapsed listen clock freq date)



(* Create a pair of processes '(scheduler, wait)'. The 'wait' process
   suspends the execution for a duration 'dur' relative to the tempo
   given by the signal 'date'. The 'scheduler' process manages the
   waitings.
*)
let make_action_scheduler date =
  signal adding in
  let sending d sl = List.iter (fun (_, s) -> emit s) sl in
  let wait = wait date adding in
  let action_scheduler = Reactive_queue.runtime date sending adding in
  action_scheduler, wait
