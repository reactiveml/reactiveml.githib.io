<div class="row-fluid">
  <div class="span3">
    <div class="well sidebar-nav sidebar-nav-fixed">
      <ul class="nav nav-list">
	<li class="nav-header">Try ReactiveML</li>
	<li><a href="<#ROOTDIR>/tryrml/tryrml.html"><i class="icon-globe icon-black"></i> Try it online</a></li>
	<li><a href="<#ROOTDIR>/distrib/rml-<#RML_VERSION>-<#DATE>.tar.gz"><i class="icon-globe icon-black"></i> Download</a></li>

        <li class="nav-header">Compilation</li>
        <li><a href="#rmlc"><i class="icon-chevron-right"></i> rmlc</a></li>
        <li><a href="#rmlbuild"><i class="icon-chevron-right"></i> rmlbuild</a></li>

        <li class="nav-header">Process</li>
        <li><a href="#process"><i class="icon-chevron-right"></i> Process definition</a></li>
        <li><a href="#statements"><i class="icon-chevron-right"></i> Basic statement</a></li>
        <li><a href="#composition"><i class="icon-chevron-right"></i> Composition</a></li>
        <li><a href="#iterators"><i class="icon-chevron-right"></i> Iterators</a></li>

	<li class="nav-header">Communication</li>
        <li><a href="#signalDecl"><i class="icon-chevron-right"></i> Signal declaration</a></li>
        <li><a href="#signalEm"><i class="icon-chevron-right"></i> Signal emission</a></li>
        <li><a href="#signalSt"><i class="icon-chevron-right"></i> Signal status</a></li>
        <li><a href="#signalVal"><i class="icon-chevron-right"></i> Signal value</a></li>


	<li class="nav-header">Control</li>
	<li><a href="#control"><i class="icon-chevron-right"></i> Control structures</a></li>
      </ul>
    </div>
  </div><!--/span-->

  <div class="span9">
    <h1>ReactiveML Manual</h1>
    <hr>


<p>
<b>ReactiveML</b> is based on
the <a href="http://www-sop.inria.fr/mimosa/rp/generalPresentation/index.html">synchronous
reactive model</a> <!-- of Boussinot --> embedded in an ML language
(here a subset of <a href="http://caml.inria.fr">OCaml</a>).  It provides
synchronous parallel composition and dynamic features like the dynamic
creation of processes. In <b>ReactiveML</b>, the reactive model is
integrated at the language level (not as a library) which leads to
safer and more natural programming.
</p>

<section id="rmlc">
<h3></h3>
<h2>Compiling ReactiveML Programs</h2>
<p>
Let <code>hello.rml</code> be a file containing the following program:
</p>
<pre>
  let process main = print_endline "Hello World!"
</pre>
<p>
To produce an executable, first the file must be compiled into pure
OCaml code using the following command&nbsp;(the <code>-s</code>
option allows to define the main process):
</p>
<pre>
  rmlc -s main hello.rml
</pre>
<p>
Then, the generated OCaml file (<code>hello.ml</code>) can compiled
and linked with the ReactiveML runtime as follows:
</p>
<pre>
  ocamlopt -o hello -I `rmlc -where` unix.cmxa rmllib.cmxa hello.ml
</pre>
<p>
It produces an executable file <code>hello</code> which
displays <code>Hello World!</code>.
</p>
</section>

<section id="rmlbuild">
<h3></h3>
<p>
You can also automate the compilation of ReactiveML programs
using <code>rmlbuild</code>. To do that, first define a
file <code>hello.rmlsim</code> which containts the main process:
</p>
<pre>
  sim: main
</pre>
<p>
Then you can compile the ReactiveML file and the generated OCaml file
in one command:
</p>
<pre>
  rmlbuild hello.rml.native
</pre>
<p>
This tool is based on <code>ocamlbuild</code>.
</p>
</section>
<br>

    <h2>Summary of ReactiveML Expressions</h2>
    <p>
      Terminal symbols are set
      in <code>typewriter font</code>.
      Non-terminal symbols are set
      in <code><i>italic font</i></code>.
      Square
      brackets <i><code>[]</code></i>
      denote optional components. Curly
      brackets <i><code>{}</code></i>
      denote zero, one or several repetitions of the enclosed
      components. Parentheses <i><code>()</code></i>
      denote grouping
      and <code><i>|</i></code>
      denotes alternatives.
    </p>
    <br>

    <!-- <div class="row-fluid"> -->
    <!--   <div class="span6"> -->
    <section id="process">
      <h3>Process Definition</h3>
<pre>
  let process <i>&lt;id&gt;</i> <i>{</i> <i>&lt;pattern&gt;</i> <i>}</i> = <i>&lt;expr&gt;</i> in <i>&lt;expr&gt;</i>
  process <i>&lt;expr&gt;</i></pre>
      <br>
      <p>
	Process definition are introduced by the <code>process</code> keyword.<br>
        A process can be named (<code>let process id ... </code>) or anonymous
        (<code>process <i>&lt;expr&gt;</i></code>).
      </p>
    </section>
    <hr>

    <section id="statements">
      <h3>Basic statements</h3>
<pre>
  nothing
  pause
  halt
  run <i>&lt;process&gt;</i></pre>
      <br>
      <p>
        <code>nothing</code> is equivalent to<code>()</code>.<br>
        <code>pause</code> suspends the
        execution until next instant.<br>
        <code>halt</code> suspends the
        execution forever.<br>
        <code>run</code> executes a process.
      </p>
    </section>
    <hr>

    <section id="composition">
      <h3>Composition</h3>
<pre>
  <i>&lt;expr&gt;</i> ; <i>&lt;expr&gt;</i>
  <i>&lt;expr&gt;</i> || <i>&lt;expr&gt;</i>
  let <i>&lt;pattern&gt;</i> = <i>&lt;expr&gt; {</i> and <i>&lt;pattern&gt;</i> = <i>&lt;expr&gt; }</i> in <i>&lt;expr&gt;</i>
  <i>&lt;expr&gt;</i> |> <i>&lt;expr&gt;</i></pre>
      <br>
      <p>
        In ReactiveML, expressions can be composed in
        sequence&nbsp;(<code>;</code>) or in
        parallel&nbsp;(<code>||</code>).
        The <code>let/and/in</code> construct computes
        several expressions in parallel and gets their values, then it
        computes the right of
        the <code>in</code>.<br><br>  The
        expression <code><i>e1</i> |> <i>e2</i></code>
        executes <code><i>e1</i></code>
        and <code><i>e2</i></code> in parallel, but at
        each instant <code><i>e1</i></code> is executed
        before <code><i>e1</i></code> (this construct
        is not supported in all runtime).
      </p>
    </section>
    <hr>

    <section id="iterators">
      <h3>Iterators</h3>
<pre>
  loop <i>&lt;expr&gt;</i> end
  while <i>&lt;expr&gt;</i> do <i>&lt;expr&gt;</i> done
  for <i>&lt;id&gt;</i> = <i>&lt;expr&gt; (</i> to <i> | </i> downto <i>) </i> do <i>&lt;expr&gt;</i> done
  for <i>&lt;id&gt;</i> = <i>&lt;expr&gt; (</i> to <i> | </i> downto <i>)</i> dopar <i>&lt;expr&gt;</i> done</pre>
<br>
      <p>
        <code>loop</code> is an infinite loop. <code>while</code>
        and <code>for/do</code> are the classical loops. They execute
        their body several times in
        sequence. Contrarily, the <code>for/dopar</code> loop
        executes its body several times in parallel.
      </p>
    </section>
    <hr>
    <!-- </div> -->

    <!-- <div class="span6"> -->
    <section id="signalDecl">
      <h3>Signal declaration</h3>
<pre>
  signal <i>&lt;id&gt; {</i> , <i>&lt;id&gt; }</i> in  <i>&lt;expr&gt;</i>
  signal <i>&lt;id&gt;</i> default <i>&lt;value&gt;</i> gather <i>&lt;function&gt;</i> in  <i>&lt;expr&gt;</i></pre>
      <br>
      <p>
        These constructs declare new signals. When a
        signal is declared, we can define how to combine
        the values emitted during an instant with the
        <code>signal/gather</code> construct. If no combination
        function is given, the behavior of the signal is
        to collect all emitted values in a list.
      </p>
    </section>
    <hr>


    <section id="signalEm">
      <h3>Signal emission</h3>
<pre>
  emit <i>&lt;signal&gt; [ &lt;value&gt; ]</i></pre>
      <br>
      <p>
        Signal emissions are instantaneous
        broadcasting. Hence, a signal is present or absent
        during an instant but it cannot have both
        status. The notation <code> emit <i>&lt;signal&gt;</i></code> is a shortcut
        for <code> emit <i>&lt;signal&gt;</i> ()</code>.
      </p>
    </section>
    <hr>

    <section id="signalSt">
      <h3>Signal status</h3>
<pre>
  present <i>&lt;signal&gt;</i> then <i>&lt;expr&gt;</i> else <i>&lt;expr&gt;</i>
  await <i>[</i> immediate <i>]</i> <i>&lt;signal&gt;</i>
  pre <i>&lt;signal&gt;</i></pre>
      <br>
<p>
  The expression <code>present</code> tests the status
  of a signal. If the signal is present,
  the <code>then</code> branch is executed
  instantaneously, otherwise the <code>else</code>
  branch is executed at the following instant.
  <br><br>

  The expression <code>await s</code>
  waits <code>s</code> to be emitted and terminates at
  the following instant. Whereas the expression
  <code>await immediate s</code> waits <code>s</code> to be emitted and
  terminates instantaneously.
  <br><br>


  Like in Esterel, the non-immediate version
  of <code>await</code> is the default one such
  that <code>await s; await s</code> waits two
  occurrences of <code>s</code>, while
  <code>await immediate s; await immediate s</code> is
  equivalent to <code>await immediate s</code>.
  <br><br>

  The expression <code>pre s</code> evaluates
  to <code>true</code> if the signal
  <code>s</code> has been emitted at the preceding
  instant. Otherwise, it evaluates to <code>false</code>.
</p>
</section>

    <hr>

    <section id="signalVal">
      <h3>Signal value</h3>
<pre>
  await <i>&lt;signal&gt; (&lt;pattern&gt;) [</i> when <i>&lt;expr&gt; ]</i> in <i>&lt;expr&gt;</i>
  await <i>[</i> immediate <i>]</i> one <i>&lt;signal&gt; (&lt;variable&gt;)</i> in <i>&lt;expr&gt;</i>
  pre ?<i>&lt;signal&gt;</i>
  last ?<i>&lt;signal&gt;</i>
  default ?<i>&lt;signal&gt;</i></pre>
      <br>
      <p>
        The <code>await/in</code> waits the
        emission of a signal. At the instant following the
        emission, the body is executed in an environment where
        the pattern is bind to the value of the signal (the
        combination of the values emitted at the preceding
        instant). Notice that the <code>await/in</code> keeps waiting when
        the value of the signal does not match the pattern or
        if the condition specified after the when keyword is
        not satisfied.<br><br>

        The <code>await/one/in</code> construct waits the emission
        of a signal to bind the pattern with one of
        the emitted values. In case of multiple
        emission during an instant, the choice of the
        value is not specified. Like <code>await</code>, the body
        of the expression is executed at the instant
        following the reception of the signal (except
        if there is the <code>immediate</code> keyword). To be
        causal by construction, there is no immediate
        version of the <code>await/in</code> construct.<br><br>

        The expression <code>pre ?s</code> evaluates to the value
        associated to <code>s</code> at the preceding instant. If <code>s</code>
        has not been emitted at the preceding instant,
        <code>pre ?s</code> is equal to the default value given at
        the declaration point of the signal. <code>last ?s</code>
        has a slight different behavior. It evaluates
        to the last value associated to <code>s</code> when it was
        emitted. While <code>s</code> has never been emitted, <code>pre
	  ?s</code> and <code>last ?s</code> both evaluates to the default
        value of <code>s</code>.<br><br>

        The <code>default</code> function returns the default value
        of a signal.
      </p>
    </section>
    <!-- </div> -->

    <hr>
    <h3>Control structures</h3>

    <section id="control">
<pre>
  do <i>&lt;expr&gt;</i> when <i>&lt;signal&gt;</i> done
  control <i>&lt;expr&gt;</i> with <i>&lt;signal&gt; [ (&lt;pattern&gt;) [</i> when <i> &lt;expr&gt; ] ]</i> done
  do <i>&lt;expr&gt;</i> until <i>&lt;signal&gt; [ (&lt;pattern&gt;) [</i> when <i> &lt;expr&gt; ] [</i> -> <i> &lt;expr&gt; ] ]</i> done</pre>
<br>
      <p>
	<code>do/when</code> and <code>control/with</code>
	allows to suspend the execution of and
	expression. The <code>do/when</code> executes its body only
	when the signal is present. The <code>control/with</code>
	switches between an active mode and a
	suspended one each time that the signal is
	present.<br><br>

	The preemption construct <code>do/until</code> stops the
	execution of its body at the end of instant
	when the signal is emitted. The second
	<code>do/until</code> executes a handler when a preemption
	occurs.
      </p>
    </section>
</div>
</div>
