    <pre>
<span class="comment-delimiter">(***************************************************************)</span>
<span class="comment-delimiter">(*                        </span><span class="comment">Reactive Asco                        </span><span class="comment-delimiter">*)</span>
<span class="comment-delimiter">(*                                                             *)</span>
<span class="comment-delimiter">(*                                                             *)</span>
<span class="comment-delimiter">(* </span><span class="comment">Implement the wait process (relative to the tempo)          </span><span class="comment-delimiter">*)</span>
<span class="comment-delimiter">(* </span><span class="comment">This is an optimized version using a priority queue.        </span><span class="comment-delimiter">*)</span>
<span class="comment-delimiter">(***************************************************************)</span>

<span class="variable-name">open</span> <span class="function-name">Types</span>
<span class="variable-name">open</span> <span class="function-name">Utils</span>

<span class="comment-delimiter">(* </span><span class="comment">Generate a regular real-time signal ck of frequence freq. </span><span class="comment-delimiter">*)</span>
<span class="type">let</span> <span class="type">process</span> tick clock freq  =
  <span class="type">let</span> period = 1. /. freq <span class="type">in</span>
  <span class="type">let</span> next = ref (<span class="function-name">Unix</span>.gettimeofday () +. period) <span class="type">in</span>
  <span class="keyword">loop</span>
    <span class="type">let</span> current = <span class="function-name">Unix</span>.gettimeofday () <span class="type">in</span>
    <span class="constant">if</span> (current &gt;= !next)
    <span class="constant">then</span>
      <span class="keyword">begin</span>
        <span class="builtin">emit</span> clock ();
        next := !next +. period
      <span class="keyword">end</span>;
    <span class="builtin">pause</span>
  <span class="keyword">end</span>


<span class="comment-delimiter">(* </span><span class="comment">Compute the delay, relative to the tempo, elapsed since the
   beginning of its execution.
</span><span class="comment-delimiter">*)</span>
<span class="type">let</span> <span class="type">process</span> elapsed listen clock freq date =
  <span class="type">let</span> period = 1. /. freq <span class="type">in</span>
  <span class="type">let</span> m = ref 0.0 <span class="type">in</span>
  <span class="constant">do</span>
    <span class="keyword">loop</span>
      <span class="type">let</span> ev = last_one listen <span class="type">in</span>
      m := !m +. ev.bps *. period;
      <span class="builtin">emit</span> date !m;
      <span class="builtin">pause</span>;
    <span class="keyword">end</span>
  <span class="constant">when</span> clock <span class="constant">done</span>

<span class="comment-delimiter">(* </span><span class="comment">Wait a delay 'dur' relatively to the tempo. The waiting process is
   realized by the scheduler. Thereofore to achieve the desired
   behavior we just need to register on the scheduler queue with the
   'queue' signal. 'date' is the current value of 'elapsed'.
</span><span class="comment-delimiter">*)</span>
<span class="type">let</span> <span class="type">process</span> wait date add_queue dur =
  <span class="type">signal</span> s <span class="type">in</span>
  <span class="type">await</span> <span class="type">immediate</span> <span class="type">one</span> date(e) <span class="type">in</span>
  <span class="builtin">emit</span> add_queue ((dur +. e),s);
  <span class="type">await</span> <span class="type">immediate</span> s

<span class="comment-delimiter">(* </span><span class="comment">Scheduler for the waiting process. Take as input the result of the
   integrator 'date' and the signal 'add_queue' to build the priority
   queue.
</span><span class="comment-delimiter">*)</span>
<span class="type">let</span> <span class="type">process</span> schedule date add_queue =
  <span class="comment-delimiter">(* </span><span class="comment">Send messages with deadlines greater than the current date</span><span class="comment-delimiter">*)</span>
  <span class="type">let</span> <span class="type">process</span> send date queue_pop =
    <span class="keyword">loop</span>
      <span class="type">await</span> <span class="type">immediate</span> <span class="type">one</span> date (d) <span class="type">in</span>
      <span class="type">let</span> sl = queue_pop d <span class="type">in</span>
      <span class="function-name">List</span>.iter (<span class="type">fun</span> s <span class="constant">-&gt;</span> <span class="builtin">emit</span> s) sl;
      <span class="builtin">pause</span>
    <span class="keyword">end</span>
  <span class="type">in</span>

  <span class="comment-delimiter">(* </span><span class="comment">Update the queue if new elements are emitted on 'add_queue' </span><span class="comment-delimiter">*)</span>
  <span class="type">let</span> <span class="type">process</span> update add_queue queue_push =
    <span class="keyword">loop</span>
      <span class="type">await</span> add_queue (v) <span class="type">in</span>
      <span class="function-name">List</span>.iter (<span class="type">fun</span> x <span class="constant">-&gt;</span> queue_push x) v
    <span class="keyword">end</span>
  <span class="type">in</span>

  <span class="comment-delimiter">(* </span><span class="comment">the process 'hold' holds the queue implemented as a signal </span><span class="comment-delimiter">*)</span>
  <span class="type">let</span> queue, queue_push, queue_pop = <span class="function-name">Rqueue</span>.make_queue () <span class="type">in</span>
  <span class="builtin">run</span> queue <span class="constant">||</span>
  <span class="builtin">run</span> (send date queue_pop) <span class="constant">||</span>
  <span class="builtin">run</span> (update add_queue queue_push)

<span class="comment-delimiter">(* </span><span class="comment">Run the processes tick and elapsed and return date </span><span class="comment-delimiter">*)</span>
<span class="type">let</span> <span class="type">process</span> metronome listen freq date =
  <span class="type">signal</span> clock <span class="type">in</span>
  <span class="builtin">run</span> (tick clock freq) <span class="constant">||</span>
  <span class="builtin">run</span> (elapsed listen clock freq date)


<span class="comment-delimiter">(* </span><span class="comment">Create a pair of processes '(scheduler, wait)'. The 'wait' process
   suspends the execution for a duration 'dur' relative to the tempo
   given by the signal 'date'. The 'scheduler' process manages the
   waitings.
</span><span class="comment-delimiter">*)</span>
<span class="type">let</span> make_scheduler date =
  <span class="type">signal</span> add_queue <span class="type">in</span>
  <span class="type">let</span> wait = wait date add_queue <span class="type">in</span>
  <span class="type">let</span> scheduler = schedule date add_queue <span class="type">in</span>
  scheduler, wait
</pre>
