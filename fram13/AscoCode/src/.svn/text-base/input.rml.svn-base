(***************************************************************)
(*                        Reactive Asco                        *)
(*                                                             *)
(*                                                             *)
(* Handle inputs                                               *)
(* Receive from Max/MSP via UDP or simulate the output of the  *)
(* listening machine                                           *)
(***************************************************************)


open Types
open Utils


(* Receive a event on channel 'listen' and emit the corresponding
   signals in the table events.
*)
let process server listen events =
  let n = Array.length events in
  let rec process track pev_index =
    await immediate one listen (ev) in
    if not (0 <= ev.index && ev.index < n) then begin
      prerr_endline "Error: the musician do not play the right score!";
      exit 1
    end;
    for i = pev_index + 1 to ev.index - 1 do
      emit events.(i) (Missed ev.index)
    done;
    emit events.(ev.index) Detected;
    pause;
    run (track ev.index)
  in
  run (track 0)

(* Receive message from Max via UDP and send them to the motor. *)
let process udp server_port listen events =
  let maxlen = 1024 in
  let sock_event = Network.init_server server_port in
  print_endline ("waiting on port : "^(string_of_int server_port));
  let rec process max_server =
    let newmsg = String.create maxlen in
    begin try
      let len,_ = Unix.recvfrom sock_event newmsg 0 maxlen [] in
      let msg = String.sub newmsg 0 len in
      let s = Str.split (Str.regexp "[ \t]+") msg in
      let c = int_of_string (List.nth s 0) in
      let b = float_of_string (List.nth s 1) /. 60. in
      let nev = {index = c; bps=b;} in
      emit listen nev
    with _ -> () end;
    pause;
    run max_server
  in
  run max_server ||
  run (server listen events)

(* Send messages on signal events corresponding to the simulation with
   'errors' the probability of error
*)
let process simulator simu errors freq listen events =
  signal clock in
  signal t in
  let period = 1. /. freq in

  (* Time in seconds (same as elapsed but without the moving tempo) *)
  let process time =
    let x = ref 0.0 in
    loop
      x := !x +. period;
      emit t !x;
      pause
    end
  in

  (* Play the simulation with a probability of error 'error'
     for each event
  *)
  let rec process play s =
    match s with
    | [] -> ()
    | (i, d, b)::s' ->
	  await immediate one t (e) in
	  if d < e then
	    let p = Random.float 100.0 in
	    begin if p > errors then
	      let nev = {index = i; bps = b /. 60.;} in
	      emit listen nev
	    end;
	    run (play s')
	  else
	    (pause; run (play s))
  in

  do run time when clock done ||
  run (Time.emit_clock clock freq) ||
  run (play simu) ||
  run (server listen events)
