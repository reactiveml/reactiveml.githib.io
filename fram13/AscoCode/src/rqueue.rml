(************** Basic queue organized with delays *************)

type 'a queue = Empty | Node of float * 'a * 'a queue * 'a queue

let rec q_push queue (delay, elt) =
  match queue with
  | Empty -> Node(delay, elt, Empty, Empty)
  | Node(d, e, left, right) ->
      if delay <= d
      then Node(delay, elt, q_push right (d, e), left)
      else Node(d, e, q_push right (delay, elt), left)

exception Queue_is_empty

let rec q_remove_top = function
  | Empty -> raise Queue_is_empty
  | Node(delay, elt, left, Empty) -> left
  | Node(delay, elt, Empty, right) -> right
  | Node(delay, elt, (Node(ldelay, lelt, _, _) as left),
         (Node(rdelay, relt, _, _) as right)) ->
           if ldelay <= rdelay
           then Node(ldelay, lelt, q_remove_top left, right)
           else Node(rdelay, relt, left, q_remove_top right)

let q_pop = function
  | Empty -> None
  | Node(delay, elt, _, _) as queue -> Some(delay, elt, q_remove_top queue)

type 'a action =
  | Push of float * 'a
  | Remove
  | Sustain of 'a queue

type 'a kind =
  | Not_yet of ((float * 'a) list * int * 'a queue option)
  | Current of 'a queue


type 'a body = {mutable state : 'a kind}

type 'a state = 'a body option

let rec fold f n acc =
  match n with
  | 0 -> acc
  | _ -> fold f (n-1) (f acc)

let apply_actions ads rms q =
  match q with
  | None -> assert false
  | Some q ->
      let q' = fold q_remove_top rms q in
      List.fold_left (fun q  x -> q_push q x) q' ads


let add_action x st =
  match x with
  | Remove ->
      begin match st with
      | Not_yet (ads, rms, q) -> Not_yet (ads, rms + 1, q)
      | Current q -> assert false
      end
  | Push e ->
      begin match st with
      | Not_yet (ads, rms, q) -> Not_yet (e::ads, rms, q)
      | Current q -> assert false
      end
  | Sustain q ->
      begin match st with
      | Not_yet (ads, rms, None) -> Not_yet (ads, rms, Some q)
      | Not_yet (ads, rms, Some _) -> assert false
      | Current q -> assert false
      end


let get_last st =
  match (last ?st) with
  | None -> assert false
  | Some st' ->
      begin match st'.state with
      | Current q -> q
      | Not_yet(ads, rms, q) ->
	  let q' = apply_actions ads rms q in
	  st'.state <- Current q';
	  q'
      end

let make_queue () =
  let combine x st =
    match st with
    | None ->
	let st' = {state = add_action x (Not_yet ([],0,None))} in
	Some st'
    | Some st' ->
	st'.state <- add_action x st'.state;
	Some st'
  in
  signal state default None gather combine in
  let process hold  =
    emit state (Sustain Empty);
    loop
      pause;
      await immediate state;
      let q = get_last state in
      emit state (Sustain q) ;
    end
  in

  let push v =
    emit state (Push v)
  in

  let pop d =
    let qq = get_last state in
    let rec aux l qq =
      match qq with
      | Empty -> l
      | _ ->
	  begin match q_pop qq with
	  | None -> l
	  | Some(d', s', qq') ->
	      if d >= d' then
	        (emit state Remove; aux (s'::l) qq')
	      else l
	  end
    in
    aux [] qq
  in

  hold, push, pop
