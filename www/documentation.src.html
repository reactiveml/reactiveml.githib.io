<div class="row-fluid row">
  <div class="span3">
    <div class="well sidebar-nav sidebar-nav-fixed">
      <ul class="nav nav-list">
	<li class="nav-header">Try ReactiveML</li>
	<li><a href="<#ROOTDIR>/tryrml/tryrml.html"><i class="icon-globe icon-black"></i> Try it online</a></li>
	<li><a href="<#ROOTDIR>/distrib/rml-<#RML_VERSION>-<#DATE>.tar.gz"><i class="icon-globe icon-black"></i> Download</a></li>

        <li class="nav-header">Compilation</li>
        <li><a href="#rmlc"><i class="icon-chevron-right"></i> rmlc</a></li>
        <li><a href="#rmlbuild"><i class="icon-chevron-right"></i> rmlbuild</a></li>

        <li class="nav-header">Process</li>
        <li><a href="#process"><i class="icon-chevron-right"></i> Process definition</a></li>
        <li><a href="#statements"><i class="icon-chevron-right"></i> Basic statement</a></li>
        <li><a href="#composition"><i class="icon-chevron-right"></i> Composition</a></li>
        <li><a href="#iterators"><i class="icon-chevron-right"></i> Iterators</a></li>

	<li class="nav-header">Communication</li>
        <li><a href="#signalDecl"><i class="icon-chevron-right"></i> Signal declaration</a></li>
        <li><a href="#signalEm"><i class="icon-chevron-right"></i> Signal emission</a></li>
        <li><a href="#signalSt"><i class="icon-chevron-right"></i> Signal status</a></li>
        <li><a href="#signalVal"><i class="icon-chevron-right"></i> Signal value</a></li>


	<li class="nav-header">Control</li>
	<li><a href="#control"><i class="icon-chevron-right"></i> Control structures</a></li>
      </ul>
    </div>
  </div><!--/span-->

  <div class="span9">
    <h1>ReactiveML Manual</h1>
    <hr>
<section id="rmlc">
<h3></h3>
<h2>Compiling ReactiveML Programs</h2>
<p>
Let <code>hello.rml</code> be a file containing the following program:
</p>
<pre>
  let process main = print_endline "Hello World!"
</pre>
<p>
To produce an executable, first the file must be compiled into pure
OCaml code using the following command&nbsp;(the <code>-s</code>
option allows to define the main process):
</p>
<pre>
  rmlc -s main hello.rml
</pre>
<p>
Then, the generated OCaml file (<code>hello.ml</code>) can compiled
and linked with the ReactiveML runtime as follows:
</p>
<pre>
  ocamlopt -o hello -I `rmlc -where` unix.cmxa rmllib.cmxa hello.ml
</pre>
<p>
It produces an executable file <code>hello</code> which
displays <code>Hello World!</code>.
</p>
</section>

<section id="rmlbuild">
<h3></h3>
<p>
You can also automate the compilation of ReactiveML programs
using <code>rmlbuild</code>. To do that, first define a
file <code>hello.rmlsim</code> which containts the main process:
</p>
<pre>
  sim: main
</pre>
<p>
Then you can compile the ReactiveML file and the generated OCaml file
in one command:
</p>
<pre>
  rmlbuild hello.rml.native
</pre>
<p>
This tool is based on <code>ocamlbuild</code>.
</p>
</section>
<br>

    <h2>Summary of ReactiveML Expressions</h2>
    <p>
      Terminal symbols are set
      in <font face="courier">typewriter font</font>.
      Non-terminal symbols are set
      in <font face="courier"><i>italic font</i></font>.
      Square
      brackets <i><font face="courier">[]</font></i>
      denote optional components. Curly
      brackets <i><font face="courier">{}</font></i>
      denote zero, one or several repetitions of the enclosed
      components. Parentheses <i><font face="courier">()</font></i>
      denote grouping
      and <font face="courier"><i>|</i></font>
      denotes alternatives.
    </p>
    <br>

    <!-- <div class="row-fluid"> -->
    <!--   <div class="span6"> -->
    <section id="process">
      <h3>Process Definition</h3>
      <font face="courier">
<pre>
  let process <i>&lt;id&gt;</i> <i>{</i> <i>&lt;pattern&gt;</i> <i>}</i> = <i>&lt;expr&gt;</i> in <i>&lt;expr&gt;</i>
  process <i>&lt;expr&gt;</i></pre>
      </font>
      <br>
      <p>
	Process definition are introduced by the <font face="courier">process</font> keyword.<br>
        A process can be named (<font face="courier">let process id ... </font>) or anonymous
        (<font face="courier">process <i>&lt;expr&gt;</i></font>).
      </p>
    </section>
    <hr>

    <section id="statements">
      <h3>Basic statements</h3>
      <font face="courier">
<pre>
  nothing
  pause
  halt
  run <i>&lt;process&gt;</i></pre>
      </font>
      <br>
      <p>
        <font face="courier">nothing</font> is equivalent to<font face="courier">()</font>.<br>
        <font face="courier">pause</font> suspends the
        execution until next instant.<br>
        <font face="courier">halt</font> suspends the
        execution forever.<br>
        <font face="courier">run</font> executes a process.
      </p>
    </section>
    <hr>

    <section id="composition">
      <h3>Composition</h3>
      <font face="courier">
<pre>
  <i>&lt;expr&gt;</i> ; <i>&lt;expr&gt;</i>
  <i>&lt;expr&gt;</i> || <i>&lt;expr&gt;</i>
  let <i>&lt;pattern&gt;</i> = <i>&lt;expr&gt; {</i> and <i>&lt;pattern&gt;</i> = <i>&lt;expr&gt; }</i> in <i>&lt;expr&gt;</i>
  <i>&lt;expr&gt;</i> |> <i>&lt;expr&gt;</i></pre>
      </font>
      <br>
      <p>
        In ReactiveML, expressions can be composed in
        sequence&nbsp;(<font face="courier">;</font>) or in
        parallel&nbsp;(<font face="courier">||</font>).
        The <font face="courier">let/and/in</font> construct computes
        several expressions in parallel and gets their values, then it
        computes the right of
        the <font face="courier">in</font>.<br><br>  The
        expression <font face="courier"><i>e1</i> |> <i>e2</i></font>
        executes <font face="courier"><i>e1</i></font>
        and <font face="courier"><i>e2</i></font> in parallel, but at
        each instant <font face="courier"><i>e1</i></font> is executed
        before <font face="courier"><i>e1</i></font> (this construct
        is not supported in all runtime).
      </p>
    </section>
    <hr>

    <section id="iterators">
      <h3>Iterators</h3>
      <font face="courier">
<pre>
  loop <i>&lt;expr&gt;</i> end
  while <i>&lt;expr&gt;</i> do <i>&lt;expr&gt;</i> done
  for <i>&lt;id&gt;</i> = <i>&lt;expr&gt; (</i> to <i> | </i> downto <i>) </i> do <i>&lt;expr&gt;</i> done
  for <i>&lt;id&gt;</i> = <i>&lt;expr&gt; (</i> to <i> | </i> downto <i>)</i> dopar <i>&lt;expr&gt;</i> done</pre>
      </font><br>
      <p>
        <font face="courier">loop</font> is an infinite loop. <font face="courier">while</font>
        and <font face="courier">for/do</font> are the classical loops. They execute
        their body several times in
        sequence. Contrarily, the <font face="courier">for/dopar</font> loop
        executes its body several times in parallel.
      </p>
    </section>
    <hr>
    <!-- </div> -->

    <!-- <div class="span6"> -->
    <section id="signalDecl">
      <h3>Signal declaration</h3>
      <font face="courier">
<pre>
  signal <i>&lt;id&gt; {</i> , <i>&lt;id&gt; }</i> in  <i>&lt;expr&gt;</i>
  signal <i>&lt;id&gt;</i> default <i>&lt;value&gt;</i> gather <i>&lt;function&gt;</i> in  <i>&lt;expr&gt;</i></pre>
      </font>
      <br>
      <p>
        These constructs declare new signals. When a
        signal is declared, we can define how to combine
        the values emitted during an instant with the
        <font face="courier">signal/gather</font> construct. If no combination
        function is given, the behavior of the signal is
        to collect all emitted values in a list.
      </p>
    </section>
    <hr>


    <section id="signalEm">
      <h3>Signal emission</h3>
      <font face="courier">
<pre>
  emit <i>&lt;signal&gt; [ &lt;value&gt; ]</i></pre>
      </font>
      <br>
      <p>
        Signal emissions are instantaneous
        broadcasting. Hence, a signal is present or absent
        during an instant but it cannot have both
        status. The notation <font face="courier"> emit <i>&lt;signal&gt;</i></font> is a shortcut
        for <font face="courier"> emit <i>&lt;signal&gt;</i> ()</font>.
      </p>
    </section>
    <hr>

    <section id="signalSt">
      <h3>Signal status</h3>
      <font face="courier">
<pre>
  present <i>&lt;signal&gt;</i> then <i>&lt;expr&gt;</i> else <i>&lt;expr&gt;</i>
  await <i>[</i> immediate <i>]</i> <i>&lt;signal&gt;</i>
  pre <i>&lt;signal&gt;</i></pre>
      </font>
      <br>
<p>
  The expression <font face="courier">present</font> tests the status
  of a signal. If the signal is present,
  the <font face="courier">then</font> branch is executed
  instantaneously, otherwise the <font face="courier">else</font>
  branch is executed at the following instant.
  <br><br>

  The expression <font face="courier">await s</font>
  waits <font face="courier">s</font> to be emitted and terminates at
  the following instant. Whereas the expression
  <font face="courier">await immediate s</font> waits <font face="courier">s</font> to be emitted and
  terminates instantaneously.
  <br><br>


  Like in Esterel, the non-immediate version
  of <font face="courier">await</font> is the default one such
  that <font face="courier">await s; await s</font> waits two
  occurrences of <font face="courier">s</font>, while
  <font face="courier">await immediate s; await immediate s</font> is
  equivalent to <font face="courier">await immediate s</font>.
  <br><br>

  The expression <font face="courier">pre s</font> evaluates
  to <font face="courier">true</font> if the signal
  <font face="courier">s</font> has been emitted at the preceding
  instant. Otherwise, it evaluates to <font face="courier">false</font>.
</p>

    <hr>

    <section id="signalVal">
      <h3>Signal value</h3>
      <font face="courier">
<pre>
  await <i>&lt;signal&gt; (&lt;pattern&gt;) [</i> when <i>&lt;expr&gt; ]</i> in <i>&lt;expr&gt;</i>
  await <i>[</i> immediate <i>]</i> one <i>&lt;signal&gt (&lt;variable&gt)</i> in <i>&lt;expr&gt;</i>
  pre ?<i>&lt;signal&gt;</i>
  last ?<i>&lt;signal&gt;</i>
  default ?<i>&lt;signal&gt;</i></pre>
      </font>
      <br>
      <p>
        The <font face="courier">await/in</font> waits the
        emission of a signal. At the instant following the
        emission, the body is executed in an environment where
        the pattern is bind to the value of the signal (the
        combination of the values emitted at the preceding
        instant). Notice that the <font face="courier">await/in</font> keeps waiting when
        the value of the signal does not match the pattern or
        if the condition specified after the when keyword is
        not satisfied.<br><br>

        The <font face="courier">await/one/in</font> construct waits the emission
        of a signal to bind the pattern with one of
        the emitted values. In case of multiple
        emission during an instant, the choice of the
        value is not specified. Like <font face="courier">await</font>, the body
        of the expression is executed at the instant
        following the reception of the signal (except
        if there is the <font face="courier">immediate</font> keyword). To be
        causal by construction, there is no immediate
        version of the <font face="courier">await/in</font> construct.<br><br>

        The expression <font face="courier">pre ?s</font> evaluates to the value
        associated to <font face="courier">s</font> at the preceding instant. If <font face="courier">s</font>
        has not been emitted at the preceding instant,
        <font face="courier">pre ?s</font> is equal to the default value given at
        the declaration point of the signal. <font face="courier">last ?s</font>
        has a slight different behavior. It evaluates
        to the last value associated to <font face="courier">s</font> when it was
        emitted. While <font face="courier">s</font> has never been emitted, <font face="courier">pre
	  ?s</font> and <font face="courier">last ?s</font> both evaluates to the default
        value of <font face="courier">s</font>.<br><br>

        The <font face="courier">default</font> function returns the default value
        of a signal.
      </p>
    </section>
    <!-- </div> -->

    <hr>
    <h3>Control structures</h3>

    <section id="control">
      <font face="courier">
<pre>
  do <i>&lt;expr&gt;</i> when <i>&lt;signal&gt;</i> done
  control <i>&lt;expr&gt;</i> with <i>&lt;signal&gt; [ (&lt;pattern&gt;) [</i> when <i> &lt;expr&gt; ]</i> done
  do <i>&lt;expr&gt;</i> until <i>&lt;signal&gt; [ (&lt;pattern&gt;) [</i> when <i> &lt;expr&gt; ] [</i> -> <i> &lt;expr&gt; ] ]</i> done</pre>
      </font><br>
      <p>
	<font face="courier">do/when</font> and <font face="courier">control/with</font>
	allows to suspend the execution of and
	expression. The <font face="courier">do/when</font> executes its body only
	when the signal is present. The <font face="courier">control/with</font>
	switches between an active mode and a
	suspended one each time that the signal is
	present.<br><br>

	The preemption construct <font face="courier">do/until</font> stops the
	execution of its body at the end of instant
	when the signal is emitted. The second
	<font face="courier">do/until</font> executes a handler when a preemption
	occurs.
      </p>
    </section>
  </div>
</div>
