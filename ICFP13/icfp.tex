%\documentclass{llncs}
\documentclass[9pt,preprint]{sigplanconf}

%\documentclass[a4paper]{article}

%\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
%\usepackage[style=alphabetic]{biblatex}
%\usepackage{csquotes}
\usepackage[english]{babel}
\usepackage{url}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{mathpartir}
\usepackage{listings}
%\usepackage{cprotect} % for listings in footnotes
\usepackage{pgf}
\usepackage[colorlinks,
            linkcolor=black,
            citecolor=black,
            urlcolor=black]{hyperref}
%\usepackage{array}
%\usepackage{multirow}
\usepackage[caption=false]{subfig} % sigplanconf complains without caption=false
\usepackage{rml}
%\usepackage{graphicx}

%\renewcommand{\ttdefault}{txtt}

\input{syntax}

\bibliographystyle{plain}

\newcommand{\todo}[1]{ {\color{red} #1}}

%\newcommand{\deq}{\stackrel{\text{\tiny def}}{=}}
\newcommand{\deq}{\triangleq}
\newcommand{\sdeq}{::=}
\newcommand\rulename[1]{\text{(\textsc{#1})\;} }

\newcommand\reactivec{\textsc{ReactiveC}}

\begin{document}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{property}{Property}
\newtheorem{lemma}{Lemma}
\newtheorem*{hypothesis}{Hypothesis}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\title{Reactivity of Cooperative Systems}
%\thanks{This work is supported by the INRIA Action d'envergure Synchronics.}
\subtitle{Application to \rml}

\authorinfo{}{}{}
%\authorinfo{ %\vspace*{-.5cm}
%           Louis Mandel \and C\'edric Pasteur \and
%            Marc Pouzet}
%{DI, \'Ecole normale sup\'erieure, 45 rue d'Ulm, 75230 Paris, France}
%{Firstname.Name@ens.fr}

\maketitle

\begin{abstract}
Cooperative scheduling enables efficient sequential implementation of concurrency. But it is up to the programmer to cooperate to ensure reactivity of the program. We present an analysis that checks the reactivity of programs by abstracting programs into so-called behaviors using a type-and-effect system. Our work is applied to the functional synchronous language \rml. We prove the soundness of our analysis with respect to the big-step semantics: a well-typed program is reactive.
\end{abstract}

\category{D.3.2}{Language Classifications}{Applicative (functional) languages; Concurrent, distributed, and parallel languages}
\category{D.3.3}{Language Constructs and Features}{Concurrent programming structures}
\category{D.3.4}{Processors}{Compilers}

\terms
Languages, Theory

\keywords
Synchronous languages; Functional languages;  Semantics; Type systems

\section{Introduction}
\label{sec:introduction}

Contributions of the paper:
\begin{itemize}
\item A reactivity analysis implemented as a type-and-effect system
\item A new approach to subeffecting using row polymorphism
\item The proof of soundness of the analysis
\end{itemize}

\section{Problem statement}

\subsection{A first example}

A simple example to introduce \rml{} and the problem of reactivity

\subsection{Intuitions and limitations}
\label{sec:intuition}

\begin{itemize}
\item No value analysis: false positives with some recursive processes
\item No analysis of the presence of signals
\item Reactivity does not equal real-time
\end{itemize}

\section{Big-step Semantics}
\label{sec:semantics}

In this section, we give an overview of the big-step semantics of \rml{}, also called the behavioral semantics. The interested reader can refer to~\cite{Mandel:2005} for a more detailed presentation. We use here the same notations.

\subsection{Abstract syntax}

We consider here a kernel of \rml{}:
%
\begin{align*}
v \sdeq & c \mid (v, v) \mid n \mid \elam{x}{e} \mid \eproc{e} \\
e \sdeq &\phantom{\mid}  x \mid c \mid (e, e) \mid \elam{x}{e} 
  \mid \eapp{e}{e} \mid \erec{x}{e} \\
  & \mid \eproc{e} \mid \erun{e} \mid \epause{}  \\
& \mid \eletpar{x}{e}{x}{e}{e} \\
 &\mid \esig{x}{e}{e}{e} \\
 & \mid \eemit{e}{e} \mid \epres{e}{e}{e} \\
 & \mid \eite{e}{e}{e} \\
 &  \mid \eloop{e} \mid \euntil{e}{e}{x}{e} 
   \mid \ewhen{e}{e} 
\end{align*}

Values are constants (integers, booleans, etc.), pairs of values, signal names $n$, functions an processes. The language is a call-by-value lambda-calculus, extended with constructs for creating~($\mathtt{process}$) and running~($\mathtt{run}$) processes, waiting for the next instant~($\mathtt{pause}$), parallel definitions~($\mathtt{let/and}$), declaring signals~($\mathtt{signal}$), emitting a signal~($\mathtt{emit}$) and several control structures: the test of presence of a signal~($\mathtt{present}$), the unconditional loop~($\mathtt{loop}$), weak preemption~($\mathtt{do/until}$) and suspension~($\mathtt{do/when}$).  The expression $\euntil{e_1}{s}{x}{e_2}$ executes its body $e_1$ and, when signal~$s$ is present, stops the execution of~$e_1$ and the executes the continuation~$e_2$ on the next instant, binding~$x$ to the value of~$s$. We denote $\_$ variables that do not appear free in the body of a $\mathtt{let}$ and $\evoid{}$ the unique value of type $\mathtt{unit}$. From this kernel, we can encode most constructs of the language, as shown in Figure~\ref{fig:derived}.
%
\begin{figure*}

\begin{small}
\begin{align*}
%\eawaitim{e} \deq &\; \ewhen{\evoid{}}{e} \\
\epar{e_1}{e_2} \deq &\; \eletpar{\_}{e_1}{\_}{e_2}{\evoid{}} \\
\elet{x}{e_1}{e_2} \deq &\; \eletpar{x}{e_1}{\_}{\evoid{}}{e_2} \\
\mathidl{let} f\, x_1\, \ldots x_p = e_1 \mathid{in} e_2
      \deq &\; \elet{f}{\elam{x_1}{\ldots \elam{x_p}{e_1}}}{e_2} \\
\mathidl{let} \mathidl{rec} f\, x_1\, \ldots x_p = e_1 \mathid{in} e_2
      \deq &\; \elet{f}{ (\erec{f}{\elam{x_1}{\ldots \elam{x_p}{e_1}}}) }{e_2} \\
\mathidl{let} \mathidl{process} f\, x_1\, \ldots x_p = e_1 \mathid{in} e_2
      \deq &\; \elet{f}{\elam{x_1}{\ldots \elam{x_p}{ \eproc{e_1} }}}{e_2} \\     
\mathidl{let} \mathidl{rec} \mathidl{process} f\, x_1\, \ldots x_p = e_1 \mathid{in} e_2
            \deq &\; \elet{f}{ (\erec{f}{\elam{x_1}{\ldots \elam{x_p}{\eproc{e_1}}}}) }{e_2} \\
\eseq{e_1}{e_2} \deq &\; \elet{\_}{e_1}{e_2}  \\
\eawait{e_1}{x}{e_2} \deq&\; \euntil{ (\eloop{\epause{}}) }{e_1}{x}{e_2}
\end{align*}
\end{small}

\caption{Derived language constructs}
\label{fig:derived}
\end{figure*}


\subsection{Semantics}

A reaction of an expression is given by the relation
\[  \bigstep{N}{e}{e'}{E}{b}{S} \]
which means during the instant, in the signal environment $S$, the expression~$e$ rewrites to~$e'$ and emits the signals in $E$. $b$ is a boolean that indicates if $e'$ has terminated. We write $n \in S$ when the signal $n$ is present in the signal environment $S$, and $n \not\in S$ otherwise.

The execution of a program is made of a (potentially infinite) number of reactions and terminates when the status $b$ is equal to true. The execution of an instant is defined by the smallest signal environment $S_i$ such that:
\[ \bigstep{N}{e_i}{e_{i+1}}{E_i}{b_i}{S_i} \]
Additional conditions express for instance the fact that the emitted values in $E_i$ must agree with the signal environment $S_i$. Again we refer the reader to~\cite{Mandel:2005} for a more complete description.



Figure~\ref{fig:big_step} shows part of the rules defining the relation. The remaining rules can be found in Appendix~\ref{sec:big_step_other}. The rule for $\epause{}$ shows the meaning of the boolean $b$: if it is false, it means that the expression is stuck waiting for the next instant. The expression $\epres{e}{e_1}{e_2}$ executes its first branch immediately if the signal is present, but executes the second branch on the next instant if the signal is absent. This delayed reaction to absence, first introduced in~\cite{Boussinot:1991}, avoids any inconsistency in the presence of signals. The body of $\mathtt{do/when}$ is executed only during the instants when the signal is present. when this body reduces to a value, the $\mathtt{do/when}$ reduces immediately to the same value. The unconditional loop executes keeps executing its body until it awaits the next instant, that is, the termination status $b$ is equal to true. In particular, an expression like $\eloop{\evoid{}}$, where the body always terminates instantaneously, does not have a semantics as it would require an infinite derivation tree.

\begin{figure*}
\begin{small}
\input{big_step}
\end{small}


\caption{Big-step semantics}
\label{fig:big_step}
\end{figure*}

\section{The algebra of behaviors}

Behaviors are used to abstract the reactive behavior of processes. A main design choice is to completely abstract values and the presence of signals. It is however necessary to keep part of the structure of the program (or an abstraction of it) in order to have a precise analysis.

\subsection{The behaviors}

The algebra of behaviors is given by:
\[
\rk \sdeq \effplus ~\mid~ \effmin ~\mid~ \effvar ~\mid~ \effpar{\rk}{\rk} ~\mid~ \effor{\rk}{\rk}
~\mid~ \effcon{\rk}{\rk}  ~\mid~ \effrec{\effvar}{\rk}  ~\mid~ \effrun{\rk}
\]

It is first necessary to distinguish (surely) instantaneous actions that takes at least one instant to execute, such as $\epause{}$, from (potentially) non-instantaneous ones like calling a pure ML function or emitting a signal. The former are denoted $\effplus{}$ while the latter are denoted $\effmin$.

Behaviors must reflect the structure of the program, starting with parallel composition and alternatives, as shown by the following examples: 
\begin{lstlisting}
let process par_comb q1 q2 =
  loop
    run q1 || run q2
  end

let process if_comb c q1 q2 =
  loop
    if c then run q1 else run q2
  end
\end{lstlisting}
In the case of the `par_comb` process, the loop is non-instantaneous if either `q1` or `q2` is non-instantaneous, while in the case of `if_comb`, both processes must be non-instantaneous. That is why behaviors include the parallel composition, simply denoted $||$, and a non-deterministic choice operator denoted $+$. This shows how values are abstracted: we only keep the different alternatives and forget about the conditions.

It is also necessary to have a notion of sequence, denoted $;$ in the language of behaviors, as illustrated by the following example. The order between the recursive call and the call to `pause` is crucial as the `good_rec` process is correct while `bad_rec` loops instantaneously:
\begin{lstlisting}
let rec process good_rec =
  pause; run good_rec

let rec process bad_rec =
    run bad_rec; pause
\end{lstlisting}
As it is defined recursively, the behavior  $\rk$  associated to `good_rec` must verify that~$ \rk = \effcon{\effplus}{\effrun{\rk}}$. The $\mathtt{run}$ operator is associated to running a process and is necessary to solve technical problems in the type system, that will be discussed in Section~\ref{sec:type_system}. This equation can be solved by introducing an explicit recursion operator $\mu$ so that $\rk = \effrec{\effvar}{\effplus}{\effrun{\effvar}}$. Recursive behaviors verify the usual property:
\[ \effrec{\effvar}{\rk} = \rk[\effvar \leftarrow \effrec{\effvar}{\rk}] \]
 Similarly, the behavior of an unconditional loop is given by $\effinf{\rk}$ where $\rk$ is the behavior of the body of the loop. It intuitively represents the infinite repetition of the behavior $\rk$ and can be defined as a recursive behavior by $\effinf{\rk} \deq \effrec{\effvar}{\effcon{\rk}{\effrun{\effvar}}}$. 

\begin{figure}[t]

\subfloat[Reactive behaviors]{
\begin{small}
\input{wf}
\end{small}
\label{fig:reactive_behavior}
}

\subfloat[Non-instantaneous behaviors]{
\begin{small}
\input{noinst}
\end{small}
\label{fig:noinst_behavior}
}

\caption{Properties of behaviors}
\end{figure}


\subsection{Reactive behaviors}
\label{sec:reactive_behavior}

Using the language of behaviors, we can now characterize the behaviors that we want to reject, that is instantaneous loops and recursions. We actually enforce a stronger sufficient condition, that can be checked easily and efficiently: there must be at least one instant before each recursive call. This condition is not necessary, as the `par_map` example of Section~\ref{} showed. As the behavior of a loop is just a particular case of recursive behavior, this condition also implies that the body of a loop is non-instantaneous.

A behavior that respect this condition is called a \emph{reactive} behavior. A behavior is reactive if for each recursive behavior $\effrec{\effvar}{\rk}$, the recursion variable $\effvar$ does not appear in the first instant of the body $\rk$. Formally, we define a predicate $\wf{R}{\rk}$ meaning that the behavior $\rk$ is reactive with respect to the set of variables $R$, that is, these variables do not appear in the first instant of $\rk$ and all the recursions inside $\rk$ are well-formed. This relation is defined in Figure~\ref{fig:reactive_behavior}. It uses the notion of \emph{non-instantaneous} behavior, denoted $\noinst{\rk}$ and defined in Figure~\ref{fig:noinst_behavior}. Indeed, in the case of $\eseq{\rk_1}{\rk_2}$, if the behavior $\rk_1$ is non-instantaneous, then it is not necessary to check if the variables in $R$ appear free in $\rk_2$. However, we still have to check that $\rk_2$ is reactive, that is, that $\wf{[]}{\rk_2}$.

The fact that variables are considered non-instantaneous means that any process taken as argument is supposed to be non-instantaneous. If this is not the case, then the verification of reactivity is done when this variable is instantiated with the actual behavior of the process.

\subsection{Equivalence on behaviors}
\label{sec:equiv_behaviors}

We can define an equivalence relation~$\effeq{}{}$ on behaviors. An important property of this relation is that it preserves reactivity, which is expressed below by Property~\ref{prop:equiv_reactivty}.

The~$\effeq{}{}$~relation is an equivalence relation, i.e. it is reflexive, symmetric and transitive. The operators $\effcon{}{}$ and $\effpar{}{}$ and $\effor{}{}$ are compatible with this relation, idempotent and associative. $\effpar{}{}$~and $\effor{}{}$ are commutative (but not $;\,$). The~$\effmin$~behavior~(resp.~$\effplus$) is the neutral element of $\effcon{}{}$ and $\effpar{}{}$ (resp.~$\effor{}{}$). The equivalence relation also verifies the following properties:
%
\begin{mathpar}
\inferrule
  { \effeq{\rk_1}{\rk_2} }
  { \effeq{\effrec{\effvar}{\rk_1}}{\effrec{\effvar}{\rk_2}} }
%
\and
%
%\effeq{\effrec{\effvar}{\rk}}{\rk[\effvar \leftarrow \effrec{\effvar}{\rk}]}
%
%\and
%
\effeq{\effinf{\effplus}}{\effplus}
\and
\effeq{\effrun{\effmin}}{\effmin}
\and
\effeq{\effrun{\effplus}}{\effplus}
\end{mathpar}

For instance, it is easy to show that:
\[
\effeq
 { \effrec{\effvar}{(\effcon{(\effpar{\effplus}{\effmin})}{(\effor{\effrun{\effvar}}{\effrun{\effvar}})})} }
 { \effrec{\effvar}{\effcon{\effplus}{\effrun{\effvar}}} }
\]

\begin{property}
\label{prop:equiv_reactivty}
if $\effeq{\rk_1}{\rk_2}$ and $\wf{R}{\rk_1}$ then $\wf{R}{\rk_2}$
\end{property}

\section{The type-and-effect system}
\label{sec:type_system}



\subsection{Notations}

Types and behaviors are defined by:
\begin{align*}
\rt \sdeq &\;\;\; \rtvar \mid T \mid \rtprod{\rt}{\rt} \mid \rtarrow{\rt}{\rt} \\
    &\;\mid \rtproc{\rt}{\rk} \mid \rtsig{\rt}{\rt} && \text{(types)} \\
\rs \sdeq &\; \rt \mid \forall \effvar.\, \rs \mid \forall \rtvar.\, \rs && \text{(type schemes)} \\
\tyenv \sdeq&\; \emptyset \mid \tyenv \tyconcat x : \rs && \text{(environments)}
\end{align*}
A type is either a type variable $\rtvar$, a base type $T$ (like $\mathtt{bool}$ or $\mathtt{unit}$), a product, a function, a process or a signal. The type of a process is parametrized by its return type and its behavior. The type of a signal is parametrized by the type of emitted values and the type of the read value.

We lift the notion of reactivity and equivalence from behaviors to types. A type is reactive if it contains only reactive behaviors. Two types are equivalent, also denoted $\tyeq{\rt_1}{\rt_2}$, if they have the same structure and their behaviors are equivalent.

Types schemes quantify universally type variables $\rtvar$ and behavior variables $\effvar$. We denote $ftv(\rt)$ (resp. $fbv(\rt)$) the set of type~(resp. beavior) variables free in $\rt$ and $fv(\rt) = ftv(\rt), fbv(\rt)$. Instantiation and generalization are defined in a classic way:
\begin{mathpar}
\rs[\rtvar \leftarrow \rt] \leq \forall \rtvar.\, \rs 
\and
\rs[\effvar \leftarrow \rk] \leq \forall \effvar.\, \rs  
\end{mathpar}
\vspace{-1.3em}
\begin{align*}
gen(\rt, e, \tyenv) = &\, \rt && \text { if $e$ is expansive} \\
gen(\rt, e, \tyenv) = &\; \forall \bar{\rtvar}.\forall \bar{\effvar}.\; \rt  && \text{ otherwise } \\
  & \text{ where }  \bar{\rtvar}, \bar{\effvar} = fv(\rt) \setminus fv(\tyenv)  
\end{align*}
As for references in ML, we have to be careful to not generalize expressions that allocate signals. We use the syntactic criterion of expansive and non-expansive expressions~\cite{Tofte:1990}.

\subsection{Typing rules}

Typing judgments are given by 
\[ \tyju{\tyenv}{e}{\rt}{\rk} \] 
meaning that, in the type environment~$\tyenv$, the expression $e$ has type $\rt$ and behavior $\rk$. The initial typing environment $\tyenv_0$ is defined by: 
\begin{align*}
\Gamma_0 \deq [
 &\eemit{}{} : \forall  \rtvar_1, \rtvar_2. \, 
        \rtarrow{ \rtsig{\rtvar_1}{\rtvar_2} }{\rtarrow{\rtvar_1}{\unit{}} }; \\
        &\mathtt{true} : \mathtt{bool};
              \mathtt{fst} : \forall \rtvar_1, \rtvar_2.\, \rtarrow{\rtprod{\rtvar_1}{\rtvar_2}}{\rtvar_1};  \ldots ]
\end{align*}

\begin{figure*}
\begin{small}
\input{rules}
\end{small}

\caption{Type-and-effect rules}
\label{fig:rules}
\end{figure*}

The rules are given in Figure~\ref{fig:rules}. If all the behaviors are erased, it is exactly the same type system as the one presented in~\cite{Mandel:2005}, which is itself an extension of ML type system. 

\begin{itemize}

\item A design choice of \rml{} is to separate pure ML expressions, that are surely instantaneous, from processes. For instance, it is impossible to call $\epause$ within the body of a function, that must be instantaneous. A static analysis done before typing checks this well-formation of expressions, denoted $k \vdash e$ in~\cite{Mandel:2005}. It should be noted that ML expressions, such that $0 \vdash e$, are always such that $\tyju{\tyenv}{e}{\rt}{\effmin}$. This is why many rules enforce the behavior of some expressions to be equal to $\effmin$. This does not add any new condition with respect to the well-formation analysis. The converse is false as the $\effmin$ behavior is associated to \emph{potentially} instantaneous processes whereas $0 \vdash e$ means that $e$ is \emph{necessarily} instantaneous.

\item We do not try to prove the termination of pure ML functions without any reactive behavior: the rule of application shows that we suppose that function calls always terminate instantaneously. That is why there is no behavior associated to functions, that is, there is no behaviors on arrows unlike traditional type-and-effect systems.

\item As explained earlier, in the case of $\epres{e}{e_1}{e_2}$, the first branch $e_1$ is executed immediately if the signal $e$ is present and the second branch $e_2$ is executed at the next instant if it is absent. This is reflected by the behavior associated to the expression. Similarly, the handler $e_2$ of $\euntil{e_1}{e}{x}{e_2}$ is executed at the instant following the presence of $e$.

\item We can also check that the encoding of primitives given in Figure~\ref{fig:derived} yields th expected behavior. This is for instance the case of $\eseq{e_1}{e_2}$
%
\begin{small}
\[ 
%\inferrule
%{
\inferrule%*[left=(Equiv)]
  { 
    \inferrule 
      {
        \tyju{\tyenv}{e_1}{\rt_1}{\rk_1} \\
        \tyju{\tyenv}{\evoid}{\unit}{\effmin} \\
        \tyju{\tyenv}{e_2}{\rt_2}{\rk_2} \\
      }
      { 
      \tyju{\tyenv}{\eletpar{\_}{e_1}{\_}{\evoid}{e_2}}{\rt_2}{ \effcon{(\effpar{\rk_1}{\effmin})}{\rk_2} } 
      } 
  }
  { \tyju{\tyenv}{\eseq{e_1}{e_2}}{\rt}{ \effcon{(\effpar{\rk_1}{\effmin})}{\rk_2} } } 
% \\
% \inferrule
%   { \effeq{\effpar{\rk_1}{\effmin}}{\rk_1}  \\ \effeq{\rk_2}{\rk_2} }
%   { \effeq{ \effcon{(\effpar{\rk_1}{\effmin})}{\rk_2} } { \effcon{\rk_1}{\rk_2} } }
%  }
%{
%  \tyju{\tyenv}{\eseq{e_1}{e_2}}{\rt_2}{ \effcon{\rk_1}{\rk_2} }
%}
\]
\end{small}
It is easy to check that $\effeq{ \effcon{(\effpar{\rk_1}{\effmin})}{\rk_2} }{ \effcon{\rk_1}{\rk_2} }$.  We can also check that $\epar{e_1}{e_2}$ has a behavior equivalent to $\effpar{\rk_1}{\rk_2}$ or that $\eawait{e_1}{x}{e_2}$ has a behavior \mbox{$\effeq{\effor{\effinf{\effplus}}{(\effcon{\effplus}{\rk_2})}}{\effcon{\effplus}{\rk_2}}$}. % ou encore que $\eawaitim{e_1}$ a un comportement instantanÃ© $\effmin$. 

\item There is no particular rules for recursive processes. The addition of the $\mathtt{run}$ operator in behaviors ensures that the behavior associated to a recursive process is always a recursive behavior, that is, $\effrec{\effvar}{\rk}$ with $\effvar \in fbv(\rk)$. Let's for instance consider the process defined by `let rec process p = run p`, written $\erec{p}{\eproc{(\erun{p})}}$ in the abstract syntax:
%
\begin{small}
\[
\inferrule
{
\inferrule
  {
   %\inferrule*[left=Equiv]
     %{
     \inferrule*
      { \tyju{\tyenv \tyconcat p : \rtproc{\beta}{\rk}}{p}{\rtproc{\beta}{\rk}}{\effmin} }
      { \tyju{\tyenv \tyconcat p : \rtproc{\beta}{\rk}}{\erun{p}} {\beta}{\effrun{\rk}} }
      %\\
      %\effeq{\effrun{\rk}}{\rk}
     %}
     %{
     %\tyju{\tyenv \tyconcat p : \rtproc{\beta}{\rk}}{\erun{p}} {\beta}{\rk}
     %}
%        \qquad \boxed{\rtvar = \rtproc{\beta}{\rk}}  
  }  
  { \tyju{\tyenv \tyconcat p : \rtproc{\beta}{\rk}}{\eproc{(\erun{p})}} {\rtproc{\beta}{\effrun{\rk}}}{\effmin} }
}
{ \tyju{\tyenv}{ \erec{p}{\eproc{(\erun{p})}} }{\rtproc{\beta}{\rk}}{\effmin} }
%\qquad \boxed{\rtvar = \rtproc{\beta}{\rk}}  
\]
\end{small}
The typing derivation shows that we must have $\effrun{\rk} = \rk$ to type this expression. The only behavior that verifies this equation is $\rk = \effrec{\effvar}{\effrun{\effvar}}$. Without $\mathtt{run}$, the typing derivation would be valid for any behavior $\rk$, for instance $\rk = \effmin$. It means that our analysis would have accepted this process even though it is obviously non-reactive. 

\item In~\cite{Mandel:2005}, the $\mathtt{loop}$ construct is encoded as a recursive process by:
%
\begin{align*}
\eloop{e} \deq &\mathid{run}(( \mathidl{rec} loop = 
     \elam{x}{ \\ &\qquad \eproc{(\eseq{\erun{x}}{\erun{(\eapp{loop}{x})}})}})\; (\eproc{e})) 
\end{align*}
If we suppose that \mbox{$\tyju{\tyenv}{e}{\rt}{\rk}$}, then we get the following types and behaviors:
%
\begin{align*}
loop:&\, \forall \effvar.\, \rtarrow{\rtproc{\rtvar}{\effvar}}
                { \\ &\qquad\qquad\qquad \rtproc{\rtvar'}{\effrec{\effvar'}{\effcon{\effrun{\effvar}}{\effrun{\effvar'}}}}}  \\
\eproc{e} :&\, \rtproc{\rt}{\rk}
\end{align*}
The behavior of this encoding is thus $\effrun{(\effrec{\effvar'}{\effcon{\effrun{\rk}}{\effrun{\effvar'}}})}$. It is not equivalent to $\effinf{\rk}$, in the sense of Section~\ref{sec:equiv_behaviors}, but it is reactive iff $\effinf{\rk}$ is, as the $\mathtt{run}$ operator does not influence reactivity. It means that we could have removed $\mathtt{loop}$ from our kernel without any influence on the result of the reactivity analysis.

\item This is not the case of $\mathtt{pause}$ that can also be encoded by:
%
\begin{align*}
\mathtt{pause} \deq &\; \esig{s}{\evoid}{(\elam{x}{\elam{y}{\mathtt{\evoid}}})}
                                    { \\ &\qquad \epres{s}{\evoid}{\evoid}}
\end{align*}
%
We have chosen to completely abstract values. As in the `imprecise` example of Section~\ref{sec:intuition}, we do not consider the fact the signal $s$ is always absent, so that only the second branch of the $\mathtt{present}$ is executed. The consequence is that the behavior computed by the type system, that is, $\effeq{\effor{\effmin}{\effcon{\effplus}{\effmin}}}{\effmin}$, is the opposite of the correct behavior of $\epause$.

\end{itemize}

\subsection{Subeffecting with row polymorphism}

The typing rule for the creation of processes intuitively mean that a process has \emph{at least} the behavior of its body. This subtyping restricted to effects is often referred to as \emph{subeffecting}~\cite{Nielson:1999}: we can always replace an effect with a bigger, i.e. less precise, one. It allows the type system to be a conservative extension of \rml{} type system, that is, we are able to give a behavior to any correct \rml{} program.

The consequence of this rule is that the principal type of an expression $\eproc{e}$ is always of the shape $\effor{\rk}{\effvar}$. The idea to use a free type variable to represent other possible types is reminiscent of Remy's row types~\cite{Remy:1993}. It makes it possible to implement subeffecting using only unification, without manipulating constraint sets as in traditional approaches~\cite{Talpin:1992a, Amtoft:1999}. This makes it easier to integrate it any existing ML type inference implementation. For instance, \ocaml{} type inference is also based on row polymorphism, so it would be easy to implement our analysis on top of the full language. 

During unification, the behavior of a process is always either a behavior variable~$\effvar$ or a row~$\effor{\rk}{\effvar}$. We could have made this fact more visible by having two different kind of behavior: behaviors and rows of behaviors. We chose here to stick with a more simple syntax. We can reuse any existing inference algorithm, like algorithm $\mW$ or $\mM$~\cite{Lee:1998a}, and only use the following algorithm for unification of behaviors:

\begin{small}
\begin{align*}
\mU_{\rk}(\effvar, \rk) = \mU_{\rk}(\rk, \effvar) =
					&\, [\effvar \mapsto  \effrec{\effvar'}{\rk[\effvar \leftarrow \effvar']} ]  \text{ if } \mathtt{occur\_check}(\effvar, \rt) \\
					= &\,  [\effvar \mapsto \rk] \\
\mU_{\rk}(\effor{\rk_1}{\effvar_1}, \effor{\rk_2}{\effvar_2}) =&\,
                  [\effvar_1 \mapsto \effor{\rk_2}{\effvar};  \effvar_1 \mapsto \effor{\rk_2}{\effvar} ]  \qquad \fresh{\effvar} \\
\mU_{\rk}(\rk, \rk) =&\, [] \\
\mU_{\rk}(\rk_1, \rk_2) =&\, \fail{} \qquad\text{otherwise}
\end{align*}
\end{small}

This unification algorithm also reuse traditional techniques for handling recursive types~\cite{Huet:1975}.

A downside of our approach is that it introduces one behavior variable for each process, so that the computed behaviors may get very big and unreadable. The purpose of the \textsc{Mask} rule is to remedy this, by using \emph{effect masking}. The idea is that if a behavior variable appearing in the behavior is free in the environment, it is not constrained so we can give it any value. In particular, we chose to replace it with $\effmin$, which is the neutral element of $\effor$.


\section{Proof of soundness}
\label{sec:soundness}

The intuition of the proof is that the first instant of a reactive behavior (as defined in Section~\ref{sec:reactive_behavior}) is a finite behavior, without any recursion. We then prove by induction on the size of behaviors that a well-typed process admits a finite derivation in the big-step semantics of Section~\ref{sec:semantics}.

\subsection{First instant of a behavior}

\begin{definition}
The \emph{first-instant behavior} of a behavior, denoted $\rkfst{\rk}$ is the part of the behavior that corresponds to the execution of the first instant of the corresponding process. It is formally defined by:
\begin{align*}
\rkfst{\effmin} =&\, \rkfst{\effplus}  = \effmin \\
\rkfst{\effvar} =&\, \effvar \\
\rkfst{\effrun{\rk}} =&\, \effrun{(\rkfst{\rk})} \\ 
\rkfst{\effpar{\rk_1}{\rk_2}} =&\, \effpar{\rkfst{\rk_1}}{\rkfst{\rk2}} \\
\rkfst{\effor{\rk_1}{\rk_2}} =&\, \effor{\rkfst{\rk_1}}{\rkfst{\rk2}} \\
\rkfst{\effcon{\rk_1}{\rk_2}} =&\, 
		\left\{ \begin{array}{ll}  
				\effcon{\rk_1}{\rkfst{\rk2}} &\text{if } \rkfst{\rk_1} = \rk_1 \\
				\rkfst{\rk_1} & \text{otherwise} 
		\end{array}\right. \\
\rkfst{\effrec{\effvar}{\rk}} =&\, \rkfst{\rk[\effvar \leftarrow \effrec{\effvar}{\rk}]}
\end{align*}
\end{definition}
In the case of a recursive behavior,  the first-instant behavior is well-defined only if the behavior is reactive, that is, the recursion is not instantaneous.

\todo{Ne le definir que pour comportement ferme ?}
\begin{definition}
A behavior is \emph{finite}, denoted $\rkfinite{\rk}$, if it does not contain any true recursive behavior. Formally, the predicate is defined by:
\begin{mathpar}
\inferrule{ }{\rkfinite{\effmin}}
\and
\inferrule{ }{\rkfinite{\effplus}}
\and
\inferrule{ }{\rkfinite{\effvar}}
\and
\inferrule{ \rkfinite{\rk_1} \\ \rkfinite{\rk_2} }{ \rkfinite{\effpar{\rk_1}{\rk_2}}  }
\and
\inferrule{ \rkfinite{\rk_1} \\ \rkfinite{\rk_2} }{ \rkfinite{\effor{\rk_1}{\rk_2}}  }
\and
\inferrule{ \rkfinite{\rk_1} \\ \rkfinite{\rk_2} }{ \rkfinite{\effcon{\rk_1}{\rk_2}}  }
\and
\inferrule{ \rkfinite{\rk} \\ \effvar \not\in fbv(\rk) }{ \rkfinite{\effrec{\effvar}{\rk} } }
\and
\inferrule{ \rkfinite{\rk} }{ \rkfinite{\effrun{\rk} } }
\end{mathpar}
\end{definition}

\begin{property}
If $\rk$ is reactive, then $\rkfst{\rk}$ is a finite behavior, i.e.:
\[ \wf{[]}{\rk} \Rightarrow \rkfinite{\rkfst{\rk}} \]
\end{property}

\subsection{Soundness}

In the introduction, we mentioned that we do not try to prove that functions terminate and only care about processes. We suppose that all functions terminate, which is reflected in the rule for application (Figure~\ref{fig:rules}) by the fact that the behavior of the application is always the instantaneous behavior $\effmin$. Before going further with the proof of soundness, we have to express this hypothesis more formally with respect to the big-step semantics.

\begin{hypothesis}
Function calls always terminate. Formally, for any ML expression $e$ such that $0 \vdash e$, there exists a finite derivation $\Pi_e$ such that:
\[ \exists v.\, \inferrule{\Pi_e}{ \bigstep{N}{e}{v} {E}{b}{S} } \] 
\end{hypothesis}

We can now express the soundness of our analysis:
\begin{theorem}[Soundness]
If \mbox{$\tyju{\tyenv}{e}{\rt}{\rk}$} and $\rt$ and $\rk$ are reactive and we suppose that function calls terminate, then there exists $e'$ such that \mbox{$\bigstep{N}{e}{e'} {E}{b}{S}$} and \mbox{$\tyju{\tyenv}{e'}{\rt}{\rk'}$} with $\rk'$ reactive.
\end{theorem}
\begin{proof}
The proof is done by induction on the size of the first-instant behavior of well-types expressions. The main point is that the behaviors of sub-expressions, but we have to be careful that we must consider only the first-instant behavior. To prove that the result is well-typed, we can classic syntactic techniques for type soundness~\cite{Pierce:2002} on the small-step semantics described in~\cite{Mandel:2005}. The proof of equivalence of the two semantics is also given in the same paper.
%
\begin{itemize}
\item Case $\eapp{e_1}{e_2}$ and $\erec{x}{e}$: By hypothesis. 

\item Case $\erun{e}$: We know that $0 \vdash e$ so there exists $\Pi$ such that 
\[ \inferrule{\Pi}{ \bigstep{N_1}{e}{\eproc{e_1}} {E}{true}{S} } \]
Then, as $\erun{e}$ is well-typed, we have that:
\[
\inferrule
  {
  \inferrule
    { \tyju{\tyenv}{e_1} {\rt}{\rk}  }
    { \tyju{\tyenv}{\eproc{e_1}} { \rtproc{\rt}{\rk} }{\effmin} }
  }
  { \tyju{\tyenv}{\erun{(\eproc{e_1})}} {\rt}{\effrun{\rk}} }
\]
As \mbox{$\rkfst{\effrun{\rk}} = \effrun{(\rkfst{\rk})}$}, we can apply the induction hypothesis on $e_1$ to get:
\[  \inferrule{\Pi_1}{ \bigstep{N_2}{e_1}{e'_1} {E_1}{b}{S} } \]
which enables us to build the complete derivation of $\erun{e}$:
\[
\inferrule
{
\inferrule{\Pi}{ \bigstep{N_1}{e}{\eproc{e_1}} {E}{true}{S} } \\
\inferrule{\Pi_1}{ \bigstep{N_2}{e_1}{e'_1} {E_1}{b}{S} }
}
{ \bigstep{N_1 \cdotp N_2}{\erun{e}}{e'_1} {E \sqcup E_1}{b}{S} }
\]

\item Case $\epause{}$: The derivation is already finite without any hypothesis.

\item Case $\epres{e}{e_1}{e_2}$: 
Like in the first case, we have:
\[ \inferrule{\Pi}{ \bigstep{N_1}{e}{n} {E}{true}{S} } \]
The typing rule is as follows:
\[ 
\inferrule%[Present]
  { \tyju{\tyenv}{e}{\rtsig{\rt_1}{\rt_2}}{\effmin} \\
    \tyju{\tyenv}{e_1}{\rt}{\rk_1}  \\
    \tyju{\tyenv}{e_2}{\rt}{\rk_2}  }
  { \tyju{\tyenv} { \epres{e}{e_1}{e_2} }{\rt}{ \effor{\rk_1}{(\effcon{\effplus}{\rk_2})} } }
\]
The are then two cases depending on the status of $n$:
\begin{itemize}
\item If \mbox{$n \in S$}: We can notice that \[ \rkfst{\effor{\rk_1}{(\effcon{\effplus}{\rk_2})}} = \effor{\rkfst{\rk_1}}{\effmin} \] so we can apply the induction hypothesis on $e_1$ and conclude. 
\item If $n \not\in S$: The derivation is finite.
\end{itemize}

\item Case $\eletpar{x_1}{e_1}{x_2}{e_2}{e}$ or $\euntil{e_1}{e_2}{x}{e_3}$: Idem.

\item Case $\ewhen{e_1}{e_2}$: We can use the same reasoning. It is interesting to note that the behavior associated to the expression, i.e. $\effor{\rk}{\effinf{\effplus}}$, is not equal to the behavior of the body, as one could expect, so that we can apply the induction hypothesis.
\end{itemize}

\end{proof}

\section{Discussion}


\subsection{Simplifying behaviors}

The behaviors computed by our type system are very big. For instance, the behavior associated to the `timer` example is 
\[ \effinf{(\effcon{(\effpar{\effmin}{\effmin})}{(\effor{\effmin}{(\effcon{\effmin}{\effmin})})})} \] 
This behavior is unnecessarily detailed and almost as big (if not bigger) than the source program. However, we can notice that this behavior is equivalent to $\effinf{\effmin}$.

We would like to use this equivalence relation on behaviors defined in Section~\ref{sec:equiv_behaviors} in our type system to reduce the size of the computed behaviors. We must  make sure that this does not break the proof of soundness of Section~\ref{sec:soundness}. This is ensured by the fact that the equivalence relation preserves reactivity, which is the only condition requested by the proof.

We can thus define a variant of the type system, with a new typing judgment $\tyjus{\tyenv}{e}{\rt}{\rk}$. It is defined by the rules given in Figure~\ref{fig:rules} with one additional rule, that allows to simplify behaviors at any time using the equivalence relation:
\[
\rulename{Equiv}
\inferrule
  { \tyjus{\tyenv}{e}{\rt}{\rk_1} \\ \effeq{\rk_1}{\rk_2} }
  { \tyjus{\tyenv}{e}{\rt}{\rk_2} } 
\]
We cannot add this rule to the original system as the proof of soundness relies on the fact that the behavior of sub-expressions is always smaller, which is no longer the case once we allow simplifications. We can also simplify some rules, by combining the original rule with the \textsc{Equiv} rule:
\begin{mathpar}
%
\inferrule%*[Left=(Signal)]
  { \tyjus{\tyenv}{e_1}{\rt_2}{\effmin}  \\ 
    \tyjus{\tyenv}{e_2}{ \rtarrow{\rt_1}{\rtarrow{\rt_2}{\rt_2}} }{\effmin} \\\\
    \tyjus{\tyenv \tyconcat x : \rtsig{\rt_1}{\rt_2}} {e} {\rt}{\rk}  }
  { \tyjus{\tyenv}{ \esig{x}{e_1}{e_2}{e} } {\rt}{ \effcon{\effmin}{\rk}} }
%
\and
%
\inferrule%[When]
  { \tyjus{\tyenv}{e_1}{\rt}{\rk} \\\\
    \tyjus{\tyenv}{e_2}{\rtsig{\rt_1}{\rt_2}}{\effmin} }
  { \tyjus{\tyenv}{ \ewhen{e_1}{e_2} } {\rt} { \effor{\rk}{\effinf{\effplus}} } } 
%
\end{mathpar}

The \textsc{Equiv} rule does not change the fact that a program is accepted or rejected by the type system. It only allows to reduce the size of computed behaviors:
\begin{property}
\label{prop:variant_system}
If $\tyjus{\tyenv}{e}{\rt}{\rk}$, then $\tyju{\tyenv}{e}{\rt'}{\rk'}$ with $\effeq{\rk}{\rk'}$ and $\tyeq{\rt}{\rt'}$.
\end{property}
\begin{proof}
Straightforward by induction on the typing rules
\end{proof}

We can then express the soundness theorem in terms of the variant of the type system:
\begin{theorem}[Soundness (variant)]
If \mbox{$\tyjus{\tyenv}{e}{\rt}{\rk}$} and $\rt$ and $\rk$ are reactive and we suppose that function calls terminate, then there exists $e'$ such that \mbox{$\bigstep{N}{e}{e'} {E}{b}{S}$} and \mbox{$\tyjus{\tyenv}{e'}{\rt}{\rk'}$} with $\rk'$ reactive.
\end{theorem}
\begin{proof}
By applying Property~\ref{prop:variant_system} and Property~\ref{prop:equiv_reactivty}.
\end{proof}

\subsection{Examples}


\subsection{Adding references}

References are not included in the kernel of our language. However, they are relevant to the matter as they can be used to encode recursivity, as in the following example that creates a process that loops instantaneously:
%
\begin{lstlisting}
let landin () =
  let f = ref (process ()) in
  f := process (run !f);
  !f
?val landin : unit -> 
        unit process[0 + (rec 'r1. run (0 + 'r1)) + 'r2]?
?W: This expression may produce an instantaneous recursion?
\end{lstlisting}
%
%?val landin : unit -> 
%        unit process[$\effor{\effor{\effmin}{\effrec{\effvar
%                         }{\effrun{(\effor{\effmin}{\effvar})}}}}{\effvar'}$] ?
As our analysis does not have any special case for recursive processes and is only based on unification, it is able to detect the reactivity issue even though there is no explicit recursivity.

\subsection{Implementation}

\section{Related work}


Subeffecting is usually expressed as a non-syntax directed rule (we reuse the same notations as in Section~\ref{sec:type_system} for better comparison):
%
\[
\inferrule
  { \tyju{\tyenv}{e}{\rt}{\rk} \\ \rk \sqsubseteq \rk' }
  { \tyju{\tyenv}{e}{\rt}{\rk'}  }
\]
%
The order $\sqsubseteq$ on effects is given by set inclusion when effects are sets (of regions for example). In our case, It is defined by:
\begin{mathpar}
\rk_1 \sqsubseteq \effor{\rk_1}{\rk_2}
\and
\rk_2 \sqsubseteq \effor{\rk_1}{\rk_2}
\and
\inferrule{ \effeq{\rk_1}{\rk_2} }{ \rk_1 \sqsubseteq \rk_2 }
\end{mathpar}

A similar approach is used in~\cite{Amtoft:1999}. It enforces effects to be \emph{simple}, that is, effects on arrows are syntactically forced to be variables. A constraint set is added to the type system to keep track of the relations between variables and effects. Subeffecting is then expressed as:
%
\[
\inferrule
  { \tyju{\tyenv, C}{e}{\rt}{\rk}   }
  {  \tyju{\tyenv, C \cup \{ \rk \sqsubseteq \effvar \} }{ \eproc{e} }{\rtproc{\rt}{\effvar}}{\effmin} }
\]

These three formulations appear to be equivalent.

\section{Conclusion}

\bibliographystyle{plain}

\begin{small}
\bibliography{biblio}
\end{small}


\appendix

\section{Other rules for the big-step semantics}
\label{sec:big_step_other}

\todo{Mettre autres regles}

\end{document}
