%\documentclass{llncs}
\documentclass[9pt,preprint]{sigplanconf}

%\documentclass[a4paper]{article}

%\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
%\usepackage[style=alphabetic]{biblatex}
%\usepackage{csquotes}
\usepackage[english]{babel}
\usepackage{url}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{mathpartir}
\usepackage{listings}
%\usepackage{cprotect} % for listings in footnotes
\usepackage{pgf}
\usepackage[colorlinks,
            linkcolor=black,
            citecolor=black,
            urlcolor=black]{hyperref}
%\usepackage{array}
%\usepackage{multirow}
\usepackage[caption=false]{subfig} % sigplanconf complains without caption=false
\usepackage{rml}
%\usepackage{graphicx}

%\renewcommand{\ttdefault}{txtt}

\input{syntax}

\bibliographystyle{plain}

\newcommand{\todo}[1]{ {\color{red} #1}}

%\newcommand{\deq}{\stackrel{\text{\tiny def}}{=}}
\newcommand{\deq}{\triangleq}
\newcommand{\sdeq}{::=}
\newcommand\rulename[1]{\text{(\textsc{#1})\;}
}

\newcommand\topck{\texttt{topck}}

\lstset{columns=fixed, basicstyle=\ttfamily, mathescape=true,
	showstringspaces=false}
\lstset{
basicstyle=\small\ttfamily,
keywordstyle= \color{Blue}\bfseries,
commentstyle=\color{Brown},
stringstyle=\color{red}}
\lstset{language={[par]rml},
aboveskip=0.3em}

\lstMakeShortInline{`}

\newcommand{\kword}[1]{\ensuremath{\mathtt{#1}}}

\newcommand\reactivec{\textsc{ReactiveC}}

\begin{document}

\abovedisplayshortskip=0.3em
\belowdisplayshortskip=0.3em
\abovedisplayskip=0.3em
\belowdisplayskip=0.3em

\newtheorem{theorem}{Theorem}[section]
\newtheorem{property}{Property}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}

\title{Reactivity of Cooperative Systems}
%\thanks{This work is supported by the INRIA Action d'envergure Synchronics.}
\subtitle{Application to \rml}

\authorinfo{}{}{}
%\authorinfo{ %\vspace*{-.5cm}
%           Louis Mandel \and C\'edric Pasteur \and
%            Marc Pouzet}
%{DI, \'Ecole normale sup\'erieure, 45 rue d'Ulm, 75230 Paris, France}
%{Firstname.Name@ens.fr}

\maketitle

\begin{abstract}
Cooperative scheduling enables efficient sequential implementation of concurrency. But it is up to the programmer to cooperate to ensure reactivity of the program. We present an analysis that checks the reactivity of programs by abstracting programs into so-called behaviors using a type-and-effect system. Our work is applied to the functional synchronous language \rml. We prove the soundness of our analysis with respect to the big-step semantics: a well-typed program is reactive.
\end{abstract}

\category{D.3.2}{Language Classifications}{Applicative (functional) languages; Concurrent, distributed, and parallel languages}
\category{D.3.3}{Language Constructs and Features}{Concurrent programming structures}
\category{D.3.4}{Processors}{Compilers}

\terms
Languages, Theory

\keywords
Synchronous languages; Functional languages;  Semantics; Type systems

\section{Introduction}
\label{sec:introduction}

Contributions of the paper:
\begin{itemize}
\item A reactivity analysis implemented as a type-and-effect system
\item A new approach to subeffecting using row polymorphism
\item The proof of soundness of the analysis
\end{itemize}

\section{Problem statement}

\subsection{A first example}

A simple example to introduce \rml{} and the problem of reactivity

\subsection{Intuitions and limitations}
\label{sec:intuition}

\begin{itemize}
\item No value analysis: false positives with some recursive processes
\item No analysis of the presence of signals
\item Reactivity does not equal real-time
\end{itemize}

\section{Big-step Semantics}

In this section, we give an overview of the big-step semantics of \rml{}, also called the behavioral semantics. The interested reader can refer to~\cite{Mandel:2005} for a more detailed presentation. We use here the same notations.

\subsection{Abstract syntax}

We consider here a kernel of \rml{}:
%
\begin{align*}
v \sdeq & c \mid (v, v) \mid n \mid \elam{x}{e} \mid \eproc{e} \\
e \sdeq &\phantom{\mid}  x \mid c \mid (e, e) \mid \elam{x}{e} 
  \mid \eapp{e}{e} \mid \erec{x}{e} \\
  & \mid \eproc{e} \mid \erun{e} \mid \epause{}  \\
& \mid \eletpar{x}{e}{x}{e}{e} \\
 &\mid \esig{x}{e}{e}{e} \\
 & \mid \eemit{e}{e} \mid \epres{e}{e}{e} \\
 & \mid \eite{e}{e}{e} \\
 &  \mid \eloop{e} \mid \euntil{e}{e}{x}{e} 
   \mid \ewhen{e}{e} 
\end{align*}

Values are constants (integers, booleans, etc.), pairs of values, signal names $n$, functions an processes. The language is a call-by-value lambda-calculus, extended with constructs for creating~($\mathtt{process}$) and running~($\mathtt{run}$) processes, waiting for the next instant~($\mathtt{pause}$), parallel definitions~($\mathtt{let/and}$), declaring signals~($\mathtt{signal}$), emitting a signal~($\mathtt{emit}$) and several control structures: the test of presence of a signal~($\mathtt{present}$), the unconditional loop~($\mathtt{loop}$), weak preemption~($\mathtt{do/until}$) and suspension~($\mathtt{do/when}$).  The expression $\euntil{e_1}{s}{x}{e_2}$ executes its body $e_1$ and, when signal~$s$ is present, stops the execution of~$e_1$ and the executes the continuation~$e_2$ on the next instant, binding~$x$ to the value of~$s$. We denote $\_$ variables that do not appear free in the body of a $\mathtt{let}$ and $\evoid{}$ the unique value of type $\mathtt{unit}$. From this kernel, we can encode most constructs of the language, as shown in Figure~\ref{fig:derived}.
%
\begin{figure*}

\begin{small}
\begin{align*}
%\eawaitim{e} \deq &\; \ewhen{\evoid{}}{e} \\
\epar{e_1}{e_2} \deq &\; \eletpar{\_}{e_1}{\_}{e_2}{\evoid{}} \\
\elet{x}{e_1}{e_2} \deq &\; \eletpar{x}{e_1}{\_}{\evoid{}}{e_2} \\
\mathidl{let} f\, x_1\, \ldots x_p = e_1 \mathid{in} e_2
      \deq &\; \elet{f}{\elam{x_1}{\ldots \elam{x_p}{e_1}}}{e_2} \\
\mathidl{let} \mathidl{rec} f\, x_1\, \ldots x_p = e_1 \mathid{in} e_2
      \deq &\; \elet{f}{ (\erec{f}{\elam{x_1}{\ldots \elam{x_p}{e_1}}}) }{e_2} \\
\mathidl{let} \mathidl{process} f\, x_1\, \ldots x_p = e_1 \mathid{in} e_2
      \deq &\; \elet{f}{\elam{x_1}{\ldots \elam{x_p}{ \eproc{e_1} }}}{e_2} \\     
\mathidl{let} \mathidl{rec} \mathidl{process} f\, x_1\, \ldots x_p = e_1 \mathid{in} e_2
            \deq &\; \elet{f}{ (\erec{f}{\elam{x_1}{\ldots \elam{x_p}{\eproc{e_1}}}}) }{e_2} \\
\eseq{e_1}{e_2} \deq &\; \elet{\_}{e_1}{e_2}  \\
\eawait{e_1}{x}{e_2} \deq&\; \euntil{ (\eloop{\epause{}}) }{e_1}{x}{e_2}
\end{align*}
\end{small}

\caption{Derived language constructs}
\label{fig:derived}
\end{figure*}


\subsection{Semantics}

A reaction of an expression is given by the relation
\[  \bigstep{N}{e}{e'}{E}{b}{S} \]
which means during the instant, in the signal environment $S$, the expression~$e$ rewrites to~$e'$ and emits the signals in $E$. $b$ is a boolean that indicates if $e'$ has terminated. We write $n \in S$ when the signal $n$ is present in the signal environment $S$, and $n \not\in S$ otherwise.

The execution of a program is made of a (potentially infinite) number of reactions and terminates when the status $b$ is equal to true. The execution of an instant is defined by the smallest signal environment $S_i$ such that:
\[ \bigstep{N}{e_i}{e_{i+1}}{E_i}{b_i}{S_i} \]
Additional conditions express for instance the fact that the emitted values in $E_i$ must agree with the signal environment $S_i$. Again we refer the reader to~\cite{Mandel:2005} for a more complete description.



Figure~\ref{fig:big_step} shows part of the rules defining the relation. The remaining rules can be found in Appendix~\ref{sec:big_step_other}. The rule for $\epause{}$ shows the meaning of the boolean $b$: if it is false, it means that the expression is stuck waiting for the next instant. The expression $\epres{e}{e_1}{e_2}$ executes its first branch immediately if the signal is present, but executes the second branch on the next instant if the signal is absent. This delayed reaction to absence, first introduced in~\cite{Boussinot:1991}, avoids any inconsistency in the presence of signals. The body of $\mathtt{do/when}$ is executed only during the instants when the signal is present. when this body reduces to a value, the $\mathtt{do/when}$ reduces immediately to the same value. The unconditional loop executes keeps executing its body until it awaits the next instant, that is, the termination status $b$ is equal to true. In particular, an expression like $\eloop{\evoid{}}$, where the body always terminates instantaneously, does not have a semantics as it would require an infinite derivation tree.

\begin{figure*}
\begin{small}
\input{big_step}
\end{small}


\caption{Big-step semantics}
\label{fig:big_step}
\end{figure*}

\section{The algebra of behaviors}

Behaviors are used to abstract the reactive behavior of processes. A main design choice is to completely abstract values and the presence of signals. It is however necessary to keep part of the structure of the program (or an abstraction of it) in order to have a precise analysis.

\subsection{The behaviors}

The algebra of behaviors is given by:
\[
\rk \sdeq \effplus ~\mid~ \effmin ~\mid~ \effvar ~\mid~ \effpar{\rk}{\rk} ~\mid~ \effor{\rk}{\rk}
~\mid~ \effcon{\rk}{\rk}  ~\mid~ \effrec{\effvar}{\rk}  ~\mid~ \effrun{\rk}
\]

It is first necessary to distinguish (surely) instantaneous actions that takes at least one instant to execute, such as $\epause{}$, from (potentially) non-instantaneous ones like calling a pure ML function or emitting a signal. The former are denoted $\effplus{}$ while the latter are denoted $\effmin$.

Behaviors must reflect the structure of the program, starting with parallel composition and alternatives, as shown by the following examples: 
\begin{lstlisting}
let process par_comb q1 q2 =
  loop
    run q1 || run q2
  end

let process if_comb c q1 q2 =
  loop
    if c then run q1 else run q2
  end
\end{lstlisting}
In the case of the `par_comb` process, the loop is non-instantaneous if either `q1` or `q2` is non-instantaneous, while in the case of `if_comb`, both processes must be non-instantaneous. That is why behaviors include the parallel composition, simply denoted $||$, and a non-deterministic choice operator denoted $+$. This shows how values are abstracted: we only keep the different alternatives and forget about the conditions.

It is also necessary to have a notion of sequence, denoted $;$ in the language of behaviors, as illustrated by the following example. The order between the recursive call and the call to `pause` is crucial as the `good_rec` process is correct while `bad_rec` loops instantaneously:
\begin{lstlisting}
let rec process good_rec =
  pause; run good_rec

let rec process bad_rec =
    run bad_rec; pause
\end{lstlisting}
As it is defined recursively, the behavior  $\rk$  associated to `good_rec` must verify that~$ \rk = \effcon{\effplus}{\effrun{\rk}}$. The $\mathtt{run}$ operator is associated to running a process and is necessary to solve technical problems in the type system, that will be discussed in Section~\ref{sec:type_system}. This equation can be solved by introducing an explicit recursion operator $\mu$ so that $\rk = \effrec{\effvar}{\effplus}{\effrun{\effvar}}$. Recursive behaviors verify the usual property:
\[ \effrec{\effvar}{\rk} = \rk[\effvar \leftarrow \effrec{\effvar}{\rk}] \]
 Similarly, the behavior of an unconditional loop is given by $\effinf{\rk}$ where $\rk$ is the behavior of the body of the loop. It intuitively represents the infinite repetition of the behavior $\rk$ and can be defined as a recursive behavior by $\effinf{\rk} \deq \effrec{\effvar}{\effcon{\rk}{\effrun{\effvar}}}$. 

\begin{figure}[t]

\subfloat[Reactive behaviors]{
\begin{small}
\input{wf}
\end{small}
\label{fig:reactive_behavior}
}

\subfloat[Non-instantaneous behaviors]{
\begin{small}
\input{noinst}
\end{small}
\label{fig:noinst_behavior}
}

\caption{Properties of behaviors}
\end{figure}


\subsection{Reactive behaviors}

Using the language of behaviors, we can now characterize the behaviors that we want to reject, that is instantaneous loops and recursions. We actually enforce a stronger sufficient condition, that can be checked easily and efficiently: there must be at least one instant before each recursive call. This condition is not necessary, as the `par_map` example of Section~\ref{} showed. As the behavior of a loop is just a particular case of recursive behavior, this condition also implies that the body of a loop is non-instantaneous.

A behavior that respect this condition is called a \emph{reactive} behavior. A behavior is reactive if for each recursive behavior $\effrec{\effvar}{\rk}$, the recursion variable $\effvar$ does not appear in the first instant of the body $\rk$. Formally, we define a predicate $\wf{R}{\rk}$ meaning that the behavior $\rk$ is reactive with respect to the set of variables $R$, that is, these variables do not appear in the first instant of $\rk$ and all the recursions inside $\rk$ are well-formed. This relation is defined in Figure~\ref{fig:reactive_behavior}. It uses the notion of \emph{non-instantaneous} behavior, denoted $\noinst{\rk}$ and defined in Figure~\ref{fig:noinst_behavior}. Indeed, in the case of $\eseq{\rk_1}{\rk_2}$, if the behavior $\rk_1$ is non-instantaneous, then it is not necessary to check if the variables in $R$ appear free in $\rk_2$. However, we still have to check that $\rk_2$ is reactive, that is, that $\wf{[]}{\rk_2}$.

The fact that variables are considered non-instantaneous means that any process taken as argument is supposed to be non-instantaneous. If this is not the case, then the verification of reactivity is done when this variable is instantiated with the actual behavior of the process.

\subsection{Equivalence on behaviors}
\label{sec:equiv_behaviors}

We can define an equivalence relation~$\effeq{}{}$ on behaviors. An important property of this relation is that it preserves reactivity, that is, if $\effeq{\rk_1}{\rk_2}$ and $\wf{R}{\rk_1}$ then $\wf{R}{\rk_2}$.

The~$\effeq{}{}$~relation is an equivalence relation, i.e. it is reflexive, symmetric and transitive. The operators $\effcon{}{}$ and $\effpar{}{}$ and $\effor{}{}$ are compatible with this relation, idempotent and associative. $\effpar{}{}$~and $\effor{}{}$ are commutative (but not $;\,$). The~$\effmin$~behavior~(resp.~$\effplus$) is the neutral element of $\effcon{}{}$ and $\effpar{}{}$ (resp.~$\effor{}{}$). The equivalence relation also verifies the following properties:
%
\begin{mathpar}
\inferrule
  { \effeq{\rk_1}{\rk_2} }
  { \effeq{\effrec{\effvar}{\rk_1}}{\effrec{\effvar}{\rk_2}} }
%
\and
%
%\effeq{\effrec{\effvar}{\rk}}{\rk[\effvar \leftarrow \effrec{\effvar}{\rk}]}
%
%\and
%
\effeq{\effinf{\effplus}}{\effplus}
\end{mathpar}

For instance, it is easy to show that:
\[
\effeq
 { \effrec{\effvar}{(\effcon{(\effpar{\effplus}{\effmin})}{(\effor{\effrun{\effvar}}{\effrun{\effvar}})})} }
 { \effrec{\effvar}{\effcon{\effplus}{\effrun{\effvar}}} }
\]

\section{The type-and-effect system}
\label{sec:type_system}



\subsection{Notations}

Types and behaviors are defined by:
\begin{align*}
\rt \sdeq &\;\;\; \rtvar \mid T \mid \rtprod{\rt}{\rt} \mid \rtarrow{\rt}{\rt} \\
    &\;\mid \rtproc{\rt}{\rk} \mid \rtsig{\rt}{\rt} && \text{(types)} \\
\rs \sdeq &\; \rt \mid \forall \effvar.\, \rs \mid \forall \rtvar.\, \rs && \text{(type schemes)} \\
\tyenv \sdeq&\; \emptyset \mid \tyenv \tyconcat x : \rs && \text{(environments)}
\end{align*}
A type is either a type variable $\rtvar$, a base type $T$ (like $\mathtt{bool}$ or $\mathtt{unit}$), a product, a function, a process or a signal. The type of a process is parametrized by its return type and its behavior. The type of a signal is parametrized by the type of emitted values and the type of the read value.

Types schemes quantify universally type variables $\rtvar$ and behavior variables $\effvar$. We denote $ftv(\rt)$ (resp. $fbv(\rt)$) the set of type~(resp. beavior) variables free in $\rt$ and $fv(\rt) = ftv(\rt), fbv(\rt)$. Instantiation and generalization are defined in a classic way:
\begin{mathpar}
\rs[\rtvar \leftarrow \rt] \leq \forall \rtvar.\, \rs 
\and
\rs[\effvar \leftarrow \rk] \leq \forall \effvar.\, \rs  
\end{mathpar}
\vspace{-1.3em}
\begin{align*}
gen(\rt, e, \tyenv) = &\, \rt && \text { if $e$ is expansive} \\
gen(\rt, e, \tyenv) = &\; \forall \bar{\rtvar}.\forall \bar{\effvar}.\; \rt  && \text{ otherwise } \\
  & \text{ where }  \bar{\rtvar}, \bar{\effvar} = fv(\rt) \setminus fv(\tyenv)  
\end{align*}
As for references in ML, we have to be careful to not generalize expressions that allocate signals. We use the syntactic criterion of expansive and non-expansive expressions~\cite{Tofte:1990}.

\subsection{Typing rules}

Typing judgments are given by 
\[ \tyju{\tyenv}{e}{\rt}{\rk} \] 
meaning that, in the type environment~$\tyenv$, the expression $e$ has type $\rt$ and behavior $\rk$. The initial typing environment $\tyenv_0$ is defined by: 
\begin{align*}
\Gamma_0 \deq [
 &\eemit{}{} : \forall  \rtvar_1, \rtvar_2. \, 
        \rtarrow{ \rtsig{\rtvar_1}{\rtvar_2} }{\rtarrow{\rtvar_1}{\unit{}} }; \\
        &\mathtt{true} : \mathtt{bool};
              \mathtt{fst} : \forall \rtvar_1, \rtvar_2.\, \rtarrow{\rtprod{\rtvar_1}{\rtvar_2}}{\rtvar_1};  \ldots ]
\end{align*}

\begin{figure*}
\begin{small}
\input{rules}
\end{small}

\caption{Type-and-effect rules}
\label{fig:rules}
\end{figure*}

The rules are given in Figure~\ref{fig:rules}. If all the behaviors are erased, it is exactly the same type system as the one presented in~\cite{Mandel:2005}, which is itself an extension of ML type system. 

\begin{itemize}

\item A design choice of \rml{} is to separate pure ML expressions, that are surely instantaneous, from processes. For instance, it is impossible to call $\epause$ within the body of a function, that must be instantaneous. A static analysis done before typing checks this well-formation of expressions, denoted $k \vdash e$ in~\cite{Mandel:2005}. It should be noted that ML expressions, such that $0 \vdash e$, are always such that $\tyju{\tyenv}{e}{\rt}{\effmin}$. This is why many rules enforce the behavior of some expressions to be equal to $\effmin$. This does not add any new condition with respect to the well-formation analysis. The converse is false as the $\effmin$ behavior is associated to \emph{potentially} instantaneous processes whereas $0 \vdash e$ means that $e$ is \emph{necessarily} instantaneous.

\item We do not try to prove the termination of pure ML functions without any reactive behavior: the rule of application shows that we suppose that function calls always terminate instantaneously. That is why there is no behavior associated to functions, that is, there is no behaviors on arrows unlike traditional type-and-effect systems.

\item As explained earlier, in the case of $\epres{e}{e_1}{e_2}$, the first branch $e_1$ is executed immediately if the signal $e$ is present and the second branch $e_2$ is executed at the next instant if it is absent. This is reflected by the behavior associated to the expression. Similarly, the handler $e_2$ of $\euntil{e_1}{e}{x}{e_2}$ is executed at the instant following the presence of $e$.

\item We can also check that the encoding of primitives given in Figure~\ref{fig:derived} yields th expected behavior. This is for instance the case of $\eseq{e_1}{e_2}$
%
\begin{small}
\[ 
\inferrule
{
\inferrule%*[left=(Equiv)]
  { 
    \inferrule 
      {
        \tyju{\tyenv}{e_1}{\rt_1}{\rk_1} \\
        \tyju{\tyenv}{\evoid}{\unit}{\effmin} \\
        \tyju{\tyenv}{e_2}{\rt_2}{\rk_2} \\
      }
      { 
      \tyju{\tyenv}{\eletpar{\_}{e_1}{\_}{\evoid}{e_2}}{\rt_2}{ \effcon{(\effpar{\rk_1}{\effmin})}{\rk_2} } 
      } 
  }
  { \tyju{\tyenv}{\eseq{e_1}{e_2}}{\rt}{ \effcon{(\effpar{\rk_1}{\effmin})}{\rk_2} } } 
 \\
 \inferrule
   { \effeq{\effpar{\rk_1}{\effmin}}{\rk_1}  \\ \effeq{\rk_2}{\rk_2} }
   { \effeq{ \effcon{(\effpar{\rk_1}{\effmin})}{\rk_2} } { \effcon{\rk_1}{\rk_2} } }
}
{
  \tyju{\tyenv}{\eseq{e_1}{e_2}}{\rt_2}{ \effcon{\rk_1}{\rk_2} }
}
\]
\end{small}
We can also check that $\epar{e_1}{e_2}$ has a behavior equivalent to $\effpar{\rk_1}{\rk_2}$ ou que $\eawait{e_1}{x}{e_2}$ a le comportement $\effeq{\effor{\effinf{\effplus}}{(\effcon{\effplus}{\rk_2})}}{\effcon{\effplus}{\rk_2}}$ après simplification. % ou encore que $\eawaitim{e_1}$ a un comportement instantané $\effmin$. 

\item There is no particular rules for recursive processes. The addition of the $\mathtt{run}$ operator in behaviors ensures that the behavior associated to a recursive process is always a recursive behavior, that is, $\effrec{\effvar}{\rk}$ with $\effvar \in fbv(\rk)$. Let's for instance consider the process defined by `let rec process p = run p`, written $\erec{p}{\eproc{(\erun{p})}}$ in the abstract syntax:
%
\begin{small}
\[
\inferrule
{
\inferrule
  {
   %\inferrule*[left=Equiv]
     %{
     \inferrule*
      { \tyju{\tyenv \tyconcat p : \rtproc{\beta}{\rk}}{p}{\rtproc{\beta}{\rk}}{\effmin} }
      { \tyju{\tyenv \tyconcat p : \rtproc{\beta}{\rk}}{\erun{p}} {\beta}{\effrun{\rk}} }
      %\\
      %\effeq{\effrun{\rk}}{\rk}
     %}
     %{
     %\tyju{\tyenv \tyconcat p : \rtproc{\beta}{\rk}}{\erun{p}} {\beta}{\rk}
     %}
%        \qquad \boxed{\rtvar = \rtproc{\beta}{\rk}}  
  }  
  { \tyju{\tyenv \tyconcat p : \rtproc{\beta}{\rk}}{\eproc{(\erun{p})}} {\rtproc{\beta}{\effrun{\rk}}}{\effmin} }
}
{ \tyju{\tyenv}{ \erec{p}{\eproc{(\erun{p})}} }{\rtproc{\beta}{\rk}}{\effmin} }
%\qquad \boxed{\rtvar = \rtproc{\beta}{\rk}}  
\]
\end{small}
The typing derivation shows that we must have $\effrun{\rk} = \rk$ to type this expression. The only behavior that verifies this equation is $\rk = \effrec{\effvar}{\effrun{\effvar}}$. Without $\mathtt{run}$, the typing derivation would be valid for any behavior $\rk$, for instance $\rk = \effmin$. It means that our analysis would have accepted this process even though it is obviously non-reactive. 

\item In~\cite{Mandel:2005}, the $\mathtt{loop}$ construct is encoded as a recursive process by:
%
\[
\eloop{e} \deq \mathid{run}(( \mathidl{rec} loop = 
     \elam{x}{\eproc{(\eseq{\erun{x}}{\erun{(\eapp{loop}{x})}})}})\; (\eproc{e})) 
\]
If we suppose that \mbox{$\tyju{\tyenv}{e}{\rt}{\rk}$}, then we get the following types and behaviors:
%
\begin{align*}
loop:&\, \forall \effvar.\, \rtarrow{\rtproc{\rtvar}{\effvar}}
                {\rtproc{\rtvar'}{\effrec{\effvar'}{\effcon{\effrun{\effvar}}{\effrun{\effvar'}}}}}  \\
\eproc{e} :&\, \rtproc{\rt}{\rk}
\end{align*}
The behavior of this encoding is thus $\effrun{(\effrec{\effvar'}{\effcon{\effrun{\rk}}{\effrun{\effvar'}}})}$. It is not equivalent to $\effinf{\rk}$, in the sense of Section~\ref{sec:equiv_behaviors}, but it is reactive iff $\effinf{\rk}$ is, as the $\mathtt{run}$ operator does not influence reactivity. It means that we could have removed $\mathtt{loop}$ from our kernel without any influence on the result of the reactivity analysis.

\item This is not the case of $\mathtt{pause}$ that can also be encoded by:
%
\begin{align*}
\mathtt{pause} \deq &\; \esig{s}{\evoid}{(\elam{x}{\elam{y}{\mathtt{\evoid}}})}
                                    { \\ &\qquad \epres{s}{\evoid}{\evoid}}
\end{align*}
%
We have chosen to completely abstract values. As in the `imprecise` example of Section~\ref{sec:intuition}, we do not consider the fact the signal $s$ is always absent, so that only the second branch of the $\mathtt{present}$ is executed. The consequence is that the behavior computed by the type system, that is, $\effeq{\effor{\effmin}{\effcon{\effplus}{\effmin}}}{\effmin}$, is the opposite of the correct behavior of $\epause$.

\end{itemize}

\subsection{Subeffecting with row polymorphism}

\begin{itemize}
\item Remind subeffecting with constraints: enough to have a conservative extension of the type system (see \cite{Nielson:1999} for instance). Subeffecting = replacing an effect with a bigger effect. Here, replace $\rk$ with $\effor{\rk}{\rk'}$.
\[
\inferrule
  { \tyju{\tyenv}{e}{\rt}{\rk} \\ \rk \sqsubseteq \rk' }
  { \tyju{\tyenv}{e}{\rt}{\rk'}  }
\]

In \cite{Amtoft:1999}, add a constraint set to the typing rules, simple types, ie effects are always variables and:
\[
\inferrule
  { \tyju{\tyenv, C}{e}{\rt}{\rk}   }
  {  \tyju{\tyenv, C \cup {\rk \sqsubseteq \effvar} }{ \eproc{e} }{\rtproc{\rt}{\effvar}}{\effmin} }
\]
For sets (like regions), $\sqsubseteq$ is subset inclusion. In our case, such that $\rk \sqsubseteq \effor{\rk}{\rk'}$.
\item Behaviors of processes are always variables or rows (we could have enforced it using different kinds)
\item Show extended unification algorithm:no explicit constraints, only collection of effects and unification
\end{itemize}

%L'algorithme prend en entrée en environnement de typage $\tyenv$ et une expression $e$ et renvoie une substitution $S$, un type $\rt$ et un effet $\rk$:
%\[ \mW(\tyenv, e) = S, \rt, \rk \]

%Description de l'algorithme:
%\begin{small}
%\begin{align*}
%\mW(\tyenv, \evoid) =&\,(id, \mathtt{unit}, \effmin) \\
%\mW(\tyenv, x) =&\, (id, \rt[\bar{\alpha} \leftarrow \bar{\beta}], \effmin) 
%          \text{ où } \tyenv(x) = \forall \bar{\alpha}.\, \rt &&  \fresh{\bar{\beta}} \\
%\mW(\tyenv, \elam{x}{e}) =&\, \mlet (S_1, \rt_1, \rk_1) = \mW(\tyenv \tyconcat x:\beta, e) && \fresh{\beta} \\
%                                          &\,  \mIn (S_1, S_1 \rtarrow{\beta}{\effor{\rk_1}{\effvar} }{\rt_1}, \effmin) \\
%\mW(\tyenv, \eapp{e_1}{e_2}) =&\, \mlet (S_1, \rt_1, \rk_1) = \mW(\tyenv, e_1)  \\
%												   &\, \mand S'_1 = \mU_{\rk}(\rk_1, \effmin) \\
%												   &\, \mand (S_2, \rt_2, \rk_2) = \mW(S'_1 S_1\tyenv, e_2) \\
%												   &\, \mand S'_2 = \mU_{\rk}(\rk_2, \effmin) \\
%												   &\, \mand S_3 = \mU(S'_2 S_2 \rt_1, \rt_2 \rightarrow \beta) && \fresh{\beta} \\
%												   &\, \mIn (S_3 S'_2 S_2 S'_1 S_1, S_3\beta) \\
%\mW(\tyenv, \elet{x}{e_1}{e_2}) =&\, \mlet (S_1, \rt_1, \rk_1) = \mW(\tyenv, e_1)  \\
%													 &\, \mand (S_2, \rt_2, \rk_2)= \mW(S_1\tyenv \tyconcat x : gen(\rt, e_1, \tyenv), e_2) \\
%													 &\, \mIn (S_2 S_1, \rt_2, \rk_1 \cup \rk_2) \\
%\mW(\tyenv, \erec{x}{e}) =&\, \mlet (S_1, \rt_1) = \mW(\tyenv \tyconcat x:\beta, e) && \fresh{\beta} \\
%										  &\, \mand  S_2 = \mU(S_1\beta, \rt_1) \\
%										  &\, \mIn (S_2 S_1, S_2 \rt_1)
%\end{align*}
%\end{small}

The inference algorithm is the algorithm $\mW$ with the collection of behaviors. Can be easily implemented in any ML type inference algorithm.

L'algorithme d'unification prend en entrée deux types $\rt_1$ et $\rt_2$ et renvoie une substitution $S$ ou échoue avec la valeur spéciale $\fail$:
\[  \mU(\rt_1, \rt_2) = S \]

Improved unification algorithm of 
\begin{small}
\begin{align*}
\mU_{\rk}(\effvar, \rk) = \mU_{\rk}(\rk, \effvar) =
					&\, [\effvar \mapsto  \effrec{\effvar'}{\rk[\effvar \leftarrow \effvar']} ]  \text{ if } \mathtt{occur\_check}(\effvar, \rt) \\
					&\,  [\effvar \mapsto \rk] \\
\mU_{\rk}(\effor{\rk_1}{\effvar_1}, \effor{\rk_2}{\effvar_2}) =&\,
                  [\effvar_1 \mapsto \effor{\rk_2}{\effvar}; \\
                  &\,\; \effvar_1 \mapsto \effor{\rk_2}{\effvar} ] && \fresh{\effvar} \\
\mU_{\rk}(\rk, \rk) =&\, [] \\
\mU_{\rk}(\rk_1, \rk_2) =&\, \fail{} && \text{ dans tous les autres cas}
\end{align*}
\end{small}


\subsection{Simplifying behaviors}

\begin{itemize}
\item In the proof of correction, we only use the fact that the behavior is reactive.
\item the equivalence on behaviors, that preserve reactivity
\item Add a new typing rule (some kind of subtyping), can also simplify some rules
\item Not in the type system as soundness relies on the fact that the size of the behavior of sub-expressions is smaller, so we cannot do any simplification
\end{itemize}

New typing rule:
\[ 
\inferrule
  { \tyju{\tyenv}{e}{\rt}{\rk_1} \\ \effeq{\rk_1}{\rk_2} }
  { \tyju{\tyenv}{e}{\rt}{\rk_2} } 
\]

\subsection{Examples}

\section{Proof of soundness}


On définit une opération $\rkfst{\rk}$ qui ne garde que l'effet correspondant au premier instant:
\begin{align*}
\rkfst{\effmin} =&\, \rkfst{\effplus}  = \effmin \\
\rkfst{\effvar} =&\, \effvar \\
\rkfst{\effrun{\rk}} =&\, \effrun{(\rkfst{\rk})} \\ 
\rkfst{\effpar{\rk_1}{\rk_2}} =&\, \effpar{\rkfst{\rk_1}}{\rkfst{\rk2}} \\
\rkfst{\effor{\rk_1}{\rk_2}} =&\, \effor{\rkfst{\rk_1}}{\rkfst{\rk2}} \\
\rkfst{\effcon{\rk_1}{\rk_2}} =&\, \effcon{\rk_1}{\rkfst{\rk2}} &&\text{ si } \rkfst{\rk_1} = \rk_1\\
\rkfst{\effcon{\rk_1}{\rk_2}} =&\, \rkfst{\rk_1} && \text{ sinon } \\
\rkfst{\effrec{\effvar}{\rk}} =&\, \rkfst{\rk[\effvar \leftarrow \effrec{\effvar}{\rk}]}
\end{align*}
Dans le cas d'un comportement récursif, $\rkfst{\rk}$ est bien défini si le comportement est réactif, mais peut ne pas etre défini sinon.

\begin{property}
Si le comportement $\rk$ est réactif, alors $\rkfst{\rk}$ est un comportement fini (i.e. il est équivalent à un comportement sans comportement récursif).
\end{property}
Cette propriété est la base de la preuve de correction. Le comportement de tout processus bien typé est fini, donc on sait que l'on va appeler un nombre fini de processus au cours de l'instant. On montre ainsi que l'exécution de l'instant est finie, sous réserve que les fonctions terminent.

\begin{theorem}[Sureté]
Si $\tyju{\tyenv}{e}{\rt}{\rk}$ et si on suppose que "les fonctions terminent", alors il existe $e'$ tel que $\bigstep{N}{e}{e'} {E}{b}{S}$ et $\tyju{\tyenv}{e'}{\rt}{\rk'}$.
\end{theorem}
\begin{proof}
On va montrer par récurrence sur la taille de $\rkfst{\rk}$ que l'on peut obtenir une dérivation finie dans la sémantique à grands pas de \rml{} pour tout terme bien typé. L'hypothèse que "les fonctions terminent" se traduit plus formellement par le fait qu'on suppose qu'il existe une dérivation finie $\Pi$ pour toute expression $e$ (surement) instantanée, c'est-à-dire:
\[ 0 \vdash e \Rightarrow \exists v.\, \inferrule{\Pi}{ \bigstep{N}{e}{v} {E}{b}{S} } \] 
(Il y a la preuve dans le Lemme 8 p. 81 de la thèse de Louis que les expressions instantanées se réduisent instantanément en une valeur ou se réduisent infiniment. On suppose ici que le deuxième cas ne peut pas arriver.)

Dans le cas des primitives réactives, on utilise l'hypothèse de récurrence sur les sous-expressions, qui ont un comportement plus petit:
\begin{itemize}
\item Cas de $\erun{e}$: On a alors que $0 \vdash e$ donc il existe $\Pi$ tel que 
\[ \inferrule{\Pi}{ \bigstep{N_1}{e}{\eproc{e_1}} {E}{true}{S} } \]
De plus, comme $\erun{e}$ est bien typé, on a:
\[
\inferrule
  {
  \inferrule
    { \tyju{\tyenv}{e_1} {\rt}{\rk}  }
    { \tyju{\tyenv}{\eproc{e_1}} { \rtproc{\rt}{\rk} }{\effmin} }
  }
  { \tyju{\tyenv}{\erun{(\eproc{e_1})}} {\rt}{\effrun{\rk}} }
\]
On peut appliquer l'hypothèse de récurrence sur $e_1$ et on obtient donc que:
\[  \inferrule{\Pi_1}{ \bigstep{N_2}{e_1}{e'_1} {E_1}{b}{S} } \]
et on peut donc construire la dérivation complète pour $\erun{e}$:
\[
\inferrule
{
\inferrule{\Pi}{ \bigstep{N_1}{e}{\eproc{e_1}} {E}{true}{S} } \\
\inferrule{\Pi_1}{ \bigstep{N_2}{e_1}{e'_1} {E_1}{b}{S} }
}
{ \bigstep{N_1 \cdotp N_2}{\erun{e}}{e'_1} {E \sqcup E_1}{b}{S} }
\]

\item Cas de $\epause{}$: La dérivation est finie sans aucune hypothèse.

\item Cas de $\epres{e}{e_1}{e_2}$: 
De la meme façon, on prouve que :
\[ \inferrule{\Pi}{ \bigstep{N_1}{e}{n} {E}{true}{S} } \]
La règle de typage nous donne:
\[ 
\inferrule%[Present]
  { \tyju{\tyenv}{e}{\rtsig{\rt_1}{\rt_2}}{\effmin} \\
    \tyju{\tyenv}{e_1}{\rt}{\rk_1}  \\
    \tyju{\tyenv}{e_2}{\rt}{\rk_2}  }
  { \tyju{\tyenv} { \epres{e}{e_1}{e_2} }{\rt}{ \effor{\rk_1}{(\effcon{\effplus}{\rk_2})} } }
\]
On doit traiter les deux cas, selon la présence du signal:
\begin{itemize}
\item Cas où $n \in S$: Alors on applique l'hypothèse de récurrence sur $e_1$  et on conclut simplement.
\item Cas où $n \not\in S$: Alors la dérivation est finie.
\end{itemize}

\item Cas de $\eletpar{x_1}{e_1}{x_2}{e_2}{e}$: Idem.

\item Cas de $\euntil{e_1}{e_2}{x}{e_3}$: Idem.

\item Cas de $\esig{x}{e_1}{e_2}{e}$: On utilise l'hypothèse sur les expressions instantanées pour $e_1$ et $e_2$. Pour traiter le cas de $e$, on doit supposer que la règle de typage est la suivante:
\[
\inferrule%*[Left=(Signal)]
  { \tyju{\tyenv}{e_1}{\rt_2}{\effmin}  \\ 
    \tyju{\tyenv}{e_2}{ \rtarrow{\rt_1}{\rtarrow{\rt_2}{\rt_2}} }{\effmin} \\
    \tyju{\tyenv \tyconcat x : \rtsig{\rt_1}{\rt_2}} {e} {\rt}{\rk}  }
  { \tyju{\tyenv}{ \esig{x}{e_1}{e_2}{e} } {\rt}{ \effcon{\effmin}{\rk}} }
\]
Le comportement donné à l'expression est équivalent mais permet d'avoir un comportement qui décroit.

\item Cas de $\ewhen{e_1}{e_2}$: On modifie de la meme façon la règle de typage devient:
\[
\inferrule%[When]
  { \tyju{\tyenv}{e_1}{\rt}{\rk} \\
    \tyju{\tyenv}{e_2}{\rtsig{\rt_1}{\rt_2}}{\effmin} }
  { \tyju{\tyenv}{ \ewhen{e_1}{e_2} } {\rt} { \effor{\rk}{\effinf{\effplus}} } } 
\]

\end{itemize}

Pour prouver que l'on obtient une expression bien typée pour l'instant suivant, on étend la preuve de correction du typage, qui est faite sur la sémantique à petits pas (dont l'équivalence avec la sémantique à grands pas a été prouvée), pour prendre en compte les comportements. On n'a besoin d'aucune propriété sur le comportement $\rk'$ de $e'$, puisqu'on n'utilise seulement le fait que ce comportement est réactif (qui est inclut dans la définition de bien typé). 

\end{proof}

\section{Related work}


\section{Conclusion}

\bibliographystyle{plain}

\begin{small}
\bibliography{biblio}
\end{small}


\appendix

\section{Other rules for the big-step semantics}
\label{sec:big_step_other}

\todo{Mettre autres regles}

\end{document}
