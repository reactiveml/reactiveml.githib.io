%\documentclass{llncs}
\documentclass[9pt,preprint]{sigplanconf}
%\documentclass[a4paper]{article}
%\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
%\usepackage[style=alphabetic]{biblatex}
%\usepackage{csquotes}
\usepackage[english]{babel}
\usepackage{url}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{mathpartir}
\usepackage{listings}
%\usepackage{cprotect} % for listings in footnotes
\usepackage{pgf}
\usepackage[colorlinks,
            linkcolor=black,
            citecolor=black,
            urlcolor=black]{hyperref}
%\usepackage{array}
%\usepackage{multirow}

% Pour avoir la police tt ligt en lmodern
\DeclareFontFamily{T1}{lmtt}{} \DeclareFontShape{T1}{lmtt}{m}{n}{<-> ec-lmtl10}{} \DeclareFontShape{T1}{lmtt}{m}{\itdefault}{<-> ec-lmtlo10}{} \DeclareFontShape{T1}{lmtt}{\bfdefault}{n}{<-> ec-lmtk10}{} \DeclareFontShape{T1}{lmtt}{\bfdefault}{\itdefault}{<-> ec-lmtko10}{}

\usepackage[caption=false]{subfig} % sigplanconf complains without caption=false
\usepackage{rml}
%\usepackage{graphicx}


%\renewcommand{\ttdefault}{pcr}
%\usepackage{beramono}
%\usepackage{bold-extra}
%\renewcommand{\ttdefault}{txtt}

\input{syntax}

\bibliographystyle{plain}

\newcommand{\todo}[1]{ {\color{red} #1}}

%\newcommand{\deq}{\stackrel{\text{\tiny def}}{=}}
\newcommand{\deq}{\triangleq}
\newcommand{\sdeq}{::=}
\newcommand\rulename[1]{\text{(\textsc{#1})\;} }

\newcommand\reactivec{\textsc{ReactiveC}}

\begin{document}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{property}{Property}
\newtheorem{lemma}{Lemma}
\newtheorem{hypothesis}{Hypothesis}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\title{Reactivity of Cooperative Systems}
%\thanks{This work is supported by the INRIA Action d'envergure Synchronics.}
\subtitle{Application to \rml}

\authorinfo{}{}{}
%\authorinfo{ %\vspace*{-.5cm}
%           Louis Mandel \and C\'edric Pasteur \and
%            Marc Pouzet}
%{DI, \'Ecole normale sup\'erieure, 45 rue d'Ulm, 75230 Paris, France}
%{Firstname.Name@ens.fr}

\maketitle

\begin{abstract}
Cooperative scheduling enables efficient sequential implementation of concurrency. But it is up to the programmer to cooperate to ensure reactivity of the program. We present an analysis that checks the reactivity of programs by abstracting programs into so-called behaviors using a type-and-effect system. Our work is applied to the functional synchronous language \rml. We prove the soundness of our analysis with respect to the big-step semantics: a well-typed program is reactive.
\end{abstract}

\category{D.3.2}{Language Classifications}{Applicative (functional) languages; Concurrent, distributed, and parallel languages}
\category{D.3.3}{Language Constructs and Features}{Concurrent programming structures}
\category{D.3.4}{Processors}{Compilers}

\terms
Languages, Theory

\keywords
Synchronous languages; Functional languages;  Semantics; Type systems

\section{Introduction}
\label{sec:introduction}

%\begin{itemize}
%\item Cooperative scheduling: enables lightweight threads, create thousands, millions of threads. Impossible with OS threads. Synchronization almost for free. Available in all languages (asynchronous computations~\cite{Syme:2011} in \fsharp, \conhaskell~\cite{Jones:1996}, \lwt~\cite{Vouillon:2008} for \ocaml), implementation easy with continuations (see \cite{Claessen:1999})
%\item Idea: Each thread cooperates with the scheduler at some point to let other processes execute
%\item Two problems:
%\begin{itemize}
%\item The programmer has to cooperate at some point. In particular in infinite loop that are characteristic of reactive and interactive systems: at each occurence of this event, do that; forever do that
%\item Cannot call blocking functions, in particluar OS primitives for I/O
%\end{itemize}

Most functional languages offer light thread facilities, either integrated in the language like the asynchronous computations~\cite{Syme:2011} in \fsharp, or available as a library like \conhaskell~\cite{Jones:1996} or \lwt~\cite{Vouillon:2008} for \ocaml. These libraries are based on cooperative scheduling: each thread of execution cooperates with the scheduler to let other threads execute. This enables an efficient and sequential implementation of concurrency, allowing to create up to millions of separate threads, which is impossible with operating system threads. Synchronization also comes almost for free, without requiring any synchronization primitive like locks. The functional paradigm makes the implementation even easier, by using \emph{continuations}~\cite{Claessen:1999}.

The downside of cooperative scheduling is that it is necessary to make sure that threads actually cooperate:
\begin{itemize}
\item The programmer has to return control to the scheduler regularly. This is in particular true for infinite loops, that are very often present in \emph{reactive} and \emph{interactive} systems~\cite{Harel:1985}. 
\item He cannot call blocking functions like operating system primitives for I/O. 
\end{itemize}

%\item Solution to the latter: never use these functions. Libraries implement cooperative alternatives, use them instead. See \cite{Marlow:2004} for an overview on how to implement these blocking operations safely.

The solution to the latter is pretty simple: never use blocking functions inside cooperative threads. All the facilities mentioned earlier provide either I/O libraries compatible with cooperative scheduling or means to safely call blocking functions. See \cite{Marlow:2004} for an overview on how to implement blocking operations safely in this context.

%\item In this paper we tackle the first issue: not forget to cooperate with the scheduler.
%\item Analysis applied to the \rml language~\cite{Mandel:2005}: a reactive extension of ML, i.e. ML with a synchronous model of concurrency~\cite{Benveniste:2003}. Divide the execution in logical time steps. Communication and computations instantaneous. Deterministic concurrency. Advantage of \rml for reactivity analysis:
%\begin{itemize}
%\item Concurrency exposed at the level of language, so easier to implement an analysis
%\item Synchrony gives a simple meaning to reactivity: a program is reactive if logical instants progress. So a program is reactive if all process cooperate at each instant. The analysis could be applied to other concurrency model, but require some hypothesis of fairness from the scheduler. Synchrony is Very strong fairness hypothesis: processes execute in lock-step.
%\end{itemize}

The goal of this paper is to design a static analysis, called \emph{reactivity analysis}, to remedy the first problem. The analysis checks that the programmer does not forget to cooperate with the scheduler.
%
Our work is applied on the \rml language~\cite{Mandel:2005}, which is an extension of ML with a synchronous model of concurrency~\cite{Benveniste:2003}. Section~\ref{sec:problem} informally introduces the language and its semantics. The idea of synchronous languages is to divide the execution of a program into discrete logical instants, where computations and communications are considered instantaneous. This results in a deterministic model of concurrency that is compatible with the dynamic creation of processes~\cite{Boussinot:1991}. Exposing concurrency at the level of the language level makes it possible to express the analysis easily, which would not have been the case if concurrency had been implemented as a library. Furthermore, synchrony gives us a simple definition for reactivity: a reactive \rml program is one where logical instants progress. It also gives us a simple condition for reactivity: a program is reactive if all processes cooperate at each instant. Doing a similar analysis with another model of concurrency would require assumptions on the fairness of the scheduler. (\todo{Synchrony is actually a very strong fairness hypothesis: processes execute in lock-step ??})



%Contributions of the paper:
%\begin{itemize}
%\item A reactivity analysis implemented as a type-and-effect system~\cite{Lucassen:1988}
%\item A new approach to subeffecting~\cite{Nielson:1999}, i.e replacing an effect with a less precise one, using row polymorphism~\cite{Remy:1993}
%\item The proof of soundness of the analysis
%\end{itemize}

The contributions of this paper are the following:
\begin{itemize}
\item A reactivity analysis presented as a type-and-effect system~\cite{Lucassen:1988} in Sections~\ref{sec:behaviors}~and~\ref{sec:type_system}.
\item A novel approach to \emph{subeffecting}~\cite{Nielson:1999}, that is, subtyping on effects, based on row polymorphism~\cite{Remy:1993} in Section~\ref{sec:subeffecting_row}.
\item A proof of the soundness of the analysis (Section~\ref{sec:soundness}) with respect to the big-step semantics of \rml (Section~\ref{sec:semantics}): \emph{a well-typed program is reactive}.
\end{itemize}

The paper ends with some discussion and examples~(Section~\ref{sec:discussion}) and related work~(Section~\ref{sec:related_work}). The work presented here is implemented in the \rml compiler.\footnote{It is available at \url{http://reactiveml.org}}

\clearpage

\section{Problem statement}
\label{sec:problem}

Let us first introduce \rml{} syntax and informal semantics using a simple program that highlights the problem of non-reactivity.\footnote{This example is taken from an email sent by a \rml programmer asking for help. It motivated the reflexion that lead to this work.} Then we will discuss the design choices and limitations of our reactivity analysis using a few other examples.

\subsection{A first example}
\label{sec:first_example}

Let us first start by creating a process that emits a signal every `timer` seconds:
%
\begin{rmlcl}
let process clock timer s =
  let time = ref (Unix.gettimeofday ()) in
  loop
    let time' = Unix.gettimeofday () in
    if time' -. !time >= timer
    then (emit s (); time := time')
  end
\end{rmlcl}
%
The `process` keyword is used to define a process, that is, a function that takes time: its execution can span several logical instants. The `clock`~process is parametrized by a float~`timer` and a signal~`s`. Signals are communication channels between processes, with instantaneous broadcast. The process starts by initializing a local reference `time` with the current time~(line 2), read using the `gettimeofday` function of the `Unix`~module from the standard library. Then it enters an infinite loop~(line 3 to 7). At each iteration, it reads the new current time and emits the unit value on the signal~`s` if enough time has elapsed~(line 6). The compiler prints the following warning when compiling this process:
\begin{lstlisting}
?Line 3, characters 2-120:
W: This expression may be an instantaneous loop?
\end{lstlisting}
The problem is that the body of the loop is instantaneous. It means that this process never cooperates, so that logical instants do not progress. To solve this problem, the programmer must explicit cooperate by calling the `pause` operator~(line~7), which awaits the next instant, at the end of the loop:
\begin{rmlcl}[5]
[...]
    then (emit s (); time := time');
    pause 
  end
\end{rmlcl}

The second part of the program is a process that prints \verb+`top'+ every time a signal `s` is emitted. 
\begin{rmlcl}[10]
let process print_clock s =
  loop
    do
      print_string "top"; print_newline ()
    when s done
  end
\end{rmlcl}
\begin{lstlisting}
?Line 11, characters 2-78:?
?W: This expression may be an instantaneous loop.?
\end{lstlisting}
%
The `do/when` construct executes its body only when the signal `s` is present (i.e. it is emitted). It terminates by returning the value of its body instantaneously after the termination of the body. Processes have a consistent view of a signal during an instant. It is either present or absent and its status cannot change during the instant.

Once again, this loop can be instantaneous, but this time it depends on the presence of the signal. While the signal `s` is absent, the process cooperates. When it is present, the body of the `do/when` executes and terminates instantaneously. So the body of the loop also terminates instantaneously, and a new iteration of the loop is started in the same logical instant. Since the signal is still present, the body of the `do/when` executes one more time, and so on. This process can also be fixed by a call to `pause`.

We can then put these two processes in parallel, after declaring a local signal `s`. The result is a program that prints \verb+`top'+ every second:
\begin{rmlcl}[18]
let process main =
  signal s default () gather (fun () () -> ()) in
  run (print_clock s) || run (clock 1. s)
\end{rmlcl}
The declaration of a signal takes as arguments the default value of the signal and a combination function that is used to compute the value of the signal in case of multiple emissions during the same instant. Here, the default value is `()` and the signal keeps this value in case of multi-emission. The `||` operator represents the synchronous parallel composition. Both branches are executed at each instant and communicate through the local signal `s`.

\subsection{Intuitions and limitations}
\label{sec:intuition}

\input{derived}

In the previous example, we have seen the first cause of non-reactivity, that is, instantaneous loops. The second one is instantaneous recursive processes, as in this example:
\begin{lstlisting}
let rec process intantaneous s =
  emit s ();
  run (intantaneous s)
?W: This expression may produce an instantaneous recursion?
\end{lstlisting}

A sufficient condition to ensure that a recursive process is reactive is to have \emph{at least one instant between the instantiation of the process and any recursive call}. The idea of our analysis is to statically check this condition.

This condition is very strong and rejects interesting programs that are reactive. For instance, the execution of a parallel `map` is rejected (the `let/and` construct executes its two branches in parallel):
\begin{lstlisting}
let rec process par_map p l =
  match l with
  | [] -> []
  | x :: l -> let x' = run (p x)
              and l' = run (par_map p l) in
              x' :: l'
?W: This expression may produce an instantaneous recursion?
\end{lstlisting}
This process does instantaneous recursive calls, but it is reactive because the recursion is finite (if the list `l` is finite). As we don't want to prove the termination of such processes, our analysis only prints warnings and does not reject programs. As ML functions are always considered instantaneous, they are reactive if and only if they terminate. This is where the syntactic separation between functions and processes helps us: we can restrict our analysis to processes and suppose that functions always terminate.
We thus avoid showing a warning for each recursive function.
%
Furthermore, we do not deal with blocking functions, like I/O, that can also make the program non-reactive. Indeed, such functions should \emph{never} be used in the context of cooperative scheduling, so no analysis is necessary.

The analysis does not either take into account the presence of signals. It over-approximates the possible behaviors, as in the following example:
\begin{lstlisting}
let rec process imprecise =
  signal s default () gather (fun () () -> ()) in
  present s then () else (* implicit pause *) ();
  run imprecise
?W: This expression may produce an instantaneous recursion?
\end{lstlisting}
%
The `present/then/else` construct executes instantaneously its first branch if the signal is present or executes the second branch with a delay of one instant if the signal is absent. This delayed reaction to absence, first introduced in~\cite{Boussinot:1991}, avoids inconsistencies in the status of signals. In the example, the signal is absent so the `else` branch is executed. It means that the recursion is not instantaneous and the process is reactive. Our analysis still prints a warning, because if the signal `s` could be present, the recursion would be instantaneous.

Finally, we only guarantee that a program will react, not that is is real-time, that is, that it reacts in a bounded time, as shown by this example:
\begin{lstlisting}
let rec process server add =
  await add(p, ack) in
  run (server add) || let v = run p in emit ack v
\end{lstlisting}
%
The `server` process receives on a signal `add` both a process `p` and a signal `ack` on which to send back the result. As it creates one new process each time the `add` signal is emitted, this program can execute an arbitrary number of processes at the same time. It is thus not real-time, but it is indeed reactive, as waiting for the value of a signal takes one instant (one has to collect and combine all the values emitted during the instant).

\section{Big-step Semantics}
\label{sec:semantics}

In this section, we give an overview of the big-step semantics of \rml{}, also called the behavioral semantics in reference to the one of \esterel~\cite{Berry:1997} from which it is inspired. The interested reader can refer to~\cite{Mandel:2005} for a more detailed presentation of this semantics.

\subsection{Abstract syntax}

We consider here a kernel of \rml{}:
%
\begin{align*}
v \sdeq &\; c \mid (v, v) \mid n \mid \elam{x}{e} \mid \eproc{e} \\
e \sdeq &\;  x \mid c \mid (e, e) \mid \elam{x}{e} 
  \mid \eapp{e}{e} \mid \erec{x}{e} \\
  & \mid \eproc{e} \mid \erun{e} \mid \epause{}  \\
& \mid \eletpar{x}{e}{x}{e}{e} \\
 &\mid \esig{x}{e}{e}{e} \\
 & \mid \eemit{e}{e} \mid \epres{e}{e}{e} \\
 & \mid \eite{e}{e}{e} \\
 &  \mid \eloop{e} \mid \euntil{e}{e}{x}{e} 
   \mid \ewhen{e}{e} 
\end{align*}

Values are constants (integers, booleans, etc.), pairs of values, signal names $n$, functions and processes. The language is a call-by-value lambda-calculus, extended with constructs for creating~($\mathtt{process}$) and running~($\mathtt{run}$) processes, waiting for the next instant~($\mathtt{pause}$), parallel definitions~($\mathtt{let/and}$), declaring signals~($\mathtt{signal}$), emitting a signal~($\mathtt{emit}$) and several control structures: the test of presence of a signal~($\mathtt{present}$), the unconditional loop~($\mathtt{loop}$), weak preemption~($\mathtt{do/until}$) and suspension~($\mathtt{do/when}$).  The expression $\euntil{e_1}{s}{x}{e_2}$ executes its body $e_1$ and, when the signal~$s$ is present, stops the execution of~$e_1$ and then executes the continuation~$e_2$ on the next instant, binding~$x$ to the value of~$s$. We denote $\_$ variables that do not appear free in the body of a $\mathtt{let}$ and $\evoid{}$ the unique value of type $\mathtt{unit}$. From this kernel, we can encode most constructs of the language, as shown in Figure~\ref{fig:derived}.

\subsection{Semantics}

The reaction of an expression is given by the relation
\[  \bigstep{N}{e}{e'}{E}{b}{S} \]
which means that during the instant, in the signal environment $S$, the expression~$e$ rewrites to~$e'$ and emits the signals in $E$. $b$ is a boolean that indicates if $e'$ has terminated. We write $n \in S$ when the signal $n$ is present in the signal environment $S$ and $n \not\in S$ otherwise. We omit all other details concerning the signal environment and refer the reader to~\cite{Mandel:2005}.
%
The execution of an instant is defined by the smallest signal environment $S_i$ such that:
\[ \bigstep{N}{e_i}{e_{i+1}}{E_i}{b_i}{S_i} \]
Additional conditions express for instance the fact that the emitted values in $E_i$ must agree with the signal environment $S_i$. Again we refer the reader to~\cite{Mandel:2005} for a more complete description.
The execution of a program is made of the succession of a (potentially infinite) number of reactions and terminates when the status $b$ is equal to true.


Figure~\ref{fig:big_step} shows part of the rules defining the relation. The remaining rules can be found in Appendix~\ref{sec:big_step_other}. 
\begin{itemize}
\item  The rule for $\epause{}$ shows the meaning of the boolean $b$: if it is false, it means that the expression is stuck waiting for the next instant.
\item The $\mathtt{let}/\mathtt{and}$ construct executes its two branches until both are terminated.
\item The unconditional loop keeps executing its body until it awaits the next instant, that is, its termination status $b$ becomes false. In particular, an expression like $\eloop{\evoid{}}$, where the body always terminates instantaneously, does not have a semantics as it would require an infinite derivation tree.
\end{itemize}

\begin{figure*}
%\begin{small}
\input{big_step}
%\end{small}


\caption{Big-step semantics}
\label{fig:big_step}
\end{figure*}

\section{The algebra of behaviors}
\label{sec:behaviors}

The idea of our analysis is to abstract processes into a simpler language called \emph{behaviors}, following the work of~\cite{Amtoft:1999}. Behaviors abstract the reactive behavior of processes. A main design choice is to completely abstract values and the presence of signals. It is however necessary to keep part of the structure of the program (or an abstraction of it) in order to have a precise analysis.

\subsection{The behaviors}

The algebra of behaviors is given by:
\[
\rk \sdeq \effplus ~\mid~ \effmin ~\mid~ \effvar ~\mid~ \effpar{\rk}{\rk} ~\mid~ \effor{\rk}{\rk}
~\mid~ \effcon{\rk}{\rk}  ~\mid~ \effrec{\effvar}{\rk}  ~\mid~ \effrun{\rk}
\]

Surely non-instantaneous actions that takes at least one instant to execute, such as $\epause$, are denoted $\effplus$. Potentially instantaneous ones, like calling a pure ML function or emitting a signal, are denoted $\effmin$. The language also includes behavior variables $\effvar$ to represent the behaviors of processes taken as arguments.

Behaviors must reflect the structure of the program, starting with parallel composition and alternatives, as shown by the following examples: 
\begin{lstlisting}
let process par_comb q1 q2 =
  loop
    run q1 || run q2
  end

let process if_comb c q1 q2 =
  loop
    if c then run q1 else run q2
  end
\end{lstlisting}
In the case of the `par_comb` process, the loop is non-instantaneous if either `q1` or `q2` is non-instantaneous, while in the case of `if_comb`, both processes must be non-instantaneous. That is why behaviors include the parallel composition, simply denoted $||$, and a non-deterministic choice operator denoted $+$. This shows how  we abstract values: we only keep the different alternatives and forget about the conditions.

It is also necessary to have a notion of sequence, denoted~$;$ in the language of behaviors, as illustrated by the two following processes:
\begin{lstlisting}
let rec process good_rec =
  pause; run good_rec

let rec process bad_rec =
    run bad_rec; pause
\end{lstlisting}
The order between the recursive call and the call to `pause` is crucial as the `good_rec` process is reactive while `bad_rec` loops instantaneously.

As it is defined recursively, the behavior  $\rk$  associated to the `good_rec` process must verify that~\mbox{$ \rk = \effcon{\effplus}{\effrun{\rk}}$}. The $\mathtt{run}$ operator is associated to running a process and is necessary to solve technical problems in the type system, that will be discussed in Section~\ref{sec:type_system}. This equation can be solved by introducing an explicit recursion operator $\mu$ so that $\rk = \effrec{\effvar}{\effcon{\effplus}{\effrun{\effvar}}}$. Recursive behaviors verify the usual property:
\[ \effrec{\effvar}{\rk} = \rk[\effvar \leftarrow \effrec{\effvar}{\rk}] \]

It should be noted that there is no operator for representing the behavior of a loop. Indeed, a loop is just a special case of recursion. The behavior of a loop, denoted $\effinf{\rk}$ (where $\rk$ is the behavior of the body of the loop) is thus defined as a recursive behavior by:
\[\effinf{\rk} \deq \effrec{\effvar}{\effcon{\rk}{\effrun{\effvar}}} \]

The order of precedence of operators is the following (from highest to lowest): $\mathtt{run}$, $;$, $+$, $||$ and finally $\mu$. So, for instance, 
\[ \effrec{\effvar}{\effpar{\rk_1}{\effor{\effrun{\rk_2}}{\effcon{\effplus}{\rk_3}}}} \] 
should be understood as 
\[ \effrec{\effvar}{(\effpar{\rk_1}{(\effor{\effrun{(\rk_2)}}{(\effcon{\effplus}{\rk_3})})})} \]


%\begin{figure}[t]
%
%\subfloat[Reactive behaviors]{
%\begin{small}
%\input{wf}
%\end{small}
%\label{fig:reactive_behavior}
%}
%
%\subfloat[Non-instantaneous behaviors]{
%\begin{small}
%\input{noinst}
%\end{small}
%\label{fig:noinst_behavior}
%}
%
%\caption{Properties of behaviors}
%\end{figure}


\subsection{Reactive behaviors}
\label{sec:reactive_behavior}

Using the language of behaviors, we can now characterize the behaviors that we want to reject, that is instantaneous loops and recursions. We actually enforce a stronger sufficient condition, that can be checked easily and efficiently: there must be at least one instant before each recursive call. This condition is not necessary, as the `par_map` example of Section~\ref{sec:intuition} showed. As the behavior of a loop is just a particular case of recursive behavior, this condition also implies that the body of a loop is non-instantaneous.

A behavior is said to be \emph{reactive} if it respects this condition, that is, if for each recursive behavior $\effrec{\effvar}{\rk}$, the recursion variable $\effvar$ does not appear in the first instant of the body $\rk$. Formally, we define a predicate $\wf{R}{\rk}$ meaning that the behavior $\rk$ is reactive with respect to the set of variables $R$, that is, these variables do not appear in the first instant of $\rk$ and all the recursions inside $\rk$ are not instantaneous. This relation is defined by:

\begin{small}
\input{wf}
\end{small}

The rule for the sequence $\eseq{\rk_1}{\rk_2}$ uses the notion of \emph{non-instantaneous} behavior, denoted $\noinst{\rk}$ and defined below. Indeed, if the behavior $\rk_1$ is non-instantaneous, then it is not necessary to check if the variables in $R$ appear free in $\rk_2$. However, we still have to check that $\rk_2$ is reactive, that is, that $\wf{\emptyset}{\rk_2}$.

\begin{small}
\input{noinst}
\end{small}

The fact that variables are considered non-instantaneous means that any process taken as argument is supposed to be non-instantan\-eous. If this is not the case, then the verification of reactivity is done when this variable is instantiated with the actual behavior of the process.

\begin{figure*}[t]
%\begin{small}
\input{rules}
%\end{small}

\caption{Type-and-effect rules}
\label{fig:rules}
\end{figure*}

\subsection{Equivalence on behaviors}
\label{sec:equiv_behaviors}

We can define an equivalence relation~$\effeq{}{}$ on behaviors. An important property of this relation is that it preserves reactivity, which is expressed below by the following property:
\begin{property}
\label{prop:equiv_reactivty}
if $\effeq{\rk_1}{\rk_2}$ and $\wf{R}{\rk_1}$ then $\wf{R}{\rk_2}$
\end{property}

The~$\effeq{}{}$~relation is an equivalence relation, i.e. it is reflexive, symmetric and transitive. The operators $\effcon{}{}$ and $\effpar{}{}$ and $\effor{}{}$ are compatible with this relation, idempotent and associative. $\effpar{}{}$~and $\effor{}{}$ are commutative (but not $;\,$). The~$\effmin$~behavior~(resp.~$\effplus$) is the neutral element of $\effcon{}{}$ and $\effpar{}{}$ (resp.~$\effor{}{}$). The equivalence relation also verifies the following properties:
%
\begin{mathpar}
\inferrule
  { \effeq{\rk_1}{\rk_2} }
  { \effeq{\effrec{\effvar}{\rk_1}}{\effrec{\effvar}{\rk_2}} }
%
\and
%
%\effeq{\effrec{\effvar}{\rk}}{\rk[\effvar \leftarrow \effrec{\effvar}{\rk}]}
%
%\and
%
\effeq{\effinf{\effplus}}{\effplus}
\and
\effeq{\effrun{\effmin}}{\effmin}
\and
\effeq{\effrun{\effplus}}{\effplus}
\end{mathpar}

For instance, it is easy to show that:
\[
\effeq
 { \effrec{\effvar}{(\effcon{(\effpar{\effplus}{\effmin})}{(\effor{\effrun{\effvar}}{\effrun{\effvar}})})} }
 { \effrec{\effvar}{\effcon{\effplus}{\effrun{\effvar}}} }
\]

\section{The type-and-effect system}
\label{sec:type_system}

The link between processes and behaviors is done by a type-and-effect system~\cite{Lucassen:1988}. The behavior of a process is the effect computed using the type system. A type system is a simple and efficient way to implement a higher-order static analysis.

\subsection{Notations}

Types and behaviors are defined by:
\begin{align*}
\rt \sdeq &\;\;\; \rtvar \mid T \mid \rtprod{\rt}{\rt} \mid \rtarrow{\rt}{\rt} \\
    &\;\mid \rtproc{\rt}{\rk} \mid \rtsig{\rt}{\rt} && \text{(types)} \\
\rs \sdeq &\; \rt \mid \forall \effvar.\, \rs \mid \forall \rtvar.\, \rs && \text{(type schemes)} \\
\tyenv \sdeq&\; \emptyset \mid \tyenv \tyconcat x : \rs && \text{(environments)}
\end{align*}
A type is either a type variable $\rtvar$, a base type $T$ (like $\mathtt{bool}$ or $\mathtt{unit}$), a product, a function, a process or a signal. The type of a process is parametrized by its return type and its behavior. The type of a signal is parametrized by the type of emitted values and the type of the read value.

We lift the notion of reactivity and equivalence from behaviors to types. A type is reactive if it contains only reactive behaviors. Two types are equivalent, also denoted $\tyeq{\rt_1}{\rt_2}$, if they have the same structure and their behaviors are equivalent.

Types schemes quantify universally over type variables $\rtvar$ and behavior variables $\effvar$. We denote $ftv(\rt)$ (resp. $fbv(\rt)$) the set of type~(resp. behavior) variables free in $\rt$ and:
\[ fv(\rt) = ftv(\rt), fbv(\rt) \] 
Instantiation and generalization are defined in a classic way:
\begin{mathpar}
\rs[\rtvar \leftarrow \rt] \leq \forall \rtvar.\, \rs 
\and
\rs[\effvar \leftarrow \rk] \leq \forall \effvar.\, \rs  
\end{mathpar}
\vspace{-1.3em}
\begin{align*}
\mathit{gen}(\rt, e, \tyenv) = &\, \rt && \text { if $e$ is expansive} \\
\mathit{gen}(\rt, e, \tyenv) = &\; \forall \bar{\rtvar}.\forall \bar{\effvar}.\; \rt  && \text{ otherwise } \\
  & \text{ where }  \bar{\rtvar}, \bar{\effvar} = fv(\rt) \setminus fv(\tyenv)  
\end{align*}
As for references in ML, we have to be careful to not generalize expressions that allocate signals. We use the syntactic criterion of expansive and non-expansive expressions~\cite{Tofte:1990}.

\subsection{Typing rules}

Typing judgments are given by 
\[ \tyju{\tyenv}{e}{\rt}{\rk} \] 
meaning that, in the type environment~$\tyenv$, the expression $e$ has type $\rt$ and behavior $\rk$. The initial typing environment $\tyenv_0$ is defined by: 
\begin{align*}
\Gamma_0 \deq [
 &\eemit{}{} : \forall  \rtvar_1, \rtvar_2. \, 
        \rtarrow{ \rtsig{\rtvar_1}{\rtvar_2} }{\rtarrow{\rtvar_1}{\unit{}} }; \\
        &\mathtt{true} : \mathtt{bool};
              \mathtt{fst} : \forall \rtvar_1, \rtvar_2.\, \rtarrow{\rtprod{\rtvar_1}{\rtvar_2}}{\rtvar_1};  \ldots ]
\end{align*}

The rules are given in Figure~\ref{fig:rules}. If all the behaviors are erased, it is exactly the same type system as the one presented in~\cite{Mandel:2005}, which is itself an extension of ML type system. 

\begin{itemize}

\item A design choice of \rml{} is to separate pure ML expressions, that are surely instantaneous, from processes. For instance, it is impossible to call $\epause$ within the body of a function, that must be instantaneous. A static analysis done before typing checks this well-formation of expressions, denoted $k \vdash e$ in~\cite{Mandel:2005}. It should be noted that ML expressions, such that $0 \vdash e$, always verify $\tyju{\tyenv}{e}{\rt}{\effmin}$. This is why many rules enforce the behavior of some expressions to be equal to $\effmin$. This does not add any new condition with respect to the well-formation analysis. The converse is false as the $\effmin$ behavior is associated to \emph{potentially} instantaneous processes whereas $0 \vdash e$ means that $e$ is \emph{necessarily} instantaneous.

\item We do not try to prove the termination of pure ML functions without any reactive behavior: the rule of application shows that we suppose that function calls always terminate instantaneously. That is why there is no behavior associated to functions, that is, there is no behaviors on arrows unlike traditional type-and-effect systems.

\item As explained earlier, in the case of $\epres{e}{e_1}{e_2}$, the first branch $e_1$ is executed immediately if the signal $e$ is present and the second branch $e_2$ is executed at the next instant if it is absent. This is reflected by the behavior associated to the expression. Similarly, the handler $e_2$ of $\euntil{e_1}{e}{x}{e_2}$ is executed at the instant following the presence of $e$.

\item We can also check that the encoding of primitives given in Figure~\ref{fig:derived} yields the expected behaviors. This is for instance the case of $\eseq{e_1}{e_2}$:
%
\par\nobreak\vspace{-2ex}{ \small
\[ 
%\inferrule
%{
\inferrule%*[left=(Equiv)]
  { 
    \inferrule 
      {
        \tyju{\tyenv}{e_1}{\rt_1}{\rk_1} \\
        \tyju{\tyenv}{\evoid}{\unit}{\effmin} \\
        \tyju{\tyenv}{e_2}{\rt_2}{\rk_2} \\
      }
      { 
      \tyju{\tyenv}{\eletpar{\_}{e_1}{\_}{\evoid}{e_2}}{\rt_2}{ \effcon{(\effpar{\rk_1}{\effmin})}{\rk_2} } 
      } 
  }
  { \tyju{\tyenv}{\eseq{e_1}{e_2}}{\rt}{ \effcon{(\effpar{\rk_1}{\effmin})}{\rk_2} } } 
% \\
% \inferrule
%   { \effeq{\effpar{\rk_1}{\effmin}}{\rk_1}  \\ \effeq{\rk_2}{\rk_2} }
%   { \effeq{ \effcon{(\effpar{\rk_1}{\effmin})}{\rk_2} } { \effcon{\rk_1}{\rk_2} } }
%  }
%{
%  \tyju{\tyenv}{\eseq{e_1}{e_2}}{\rt_2}{ \effcon{\rk_1}{\rk_2} }
%}
\]
}%
It is easy to check that $\effeq{ \effcon{(\effpar{\rk_1}{\effmin})}{\rk_2} }{ \effcon{\rk_1}{\rk_2} }$.  We can also check that $\epar{e_1}{e_2}$ has a behavior equivalent to $\effpar{\rk_1}{\rk_2}$ or that $\eawait{e_1}{x}{e_2}$ has a behavior \mbox{$\effeq{\effor{\effinf{\effplus}}{(\effcon{\effplus}{\rk_2})}}{\effcon{\effplus}{\rk_2}}$}. % ou encore que $\eawaitim{e_1}$ a un comportement instantané $\effmin$. 

\item There is no particular rules for recursive processes. The addition of the $\mathtt{run}$ operator in behaviors ensures that the behavior associated to a recursive process is always a recursive behavior, that is, $\effrec{\effvar}{\rk}$ with $\effvar \in fbv(\rk)$. Let's for instance consider the process defined by `let rec process p = run p`, written $\erec{p}{\eproc{(\erun{p})}}$ in the abstract syntax:
%
\[
\inferrule
{
\inferrule
  {
   %\inferrule*[left=Equiv]
     %{
     \inferrule*
      { \tyju{\tyenv'}{p}{\rtproc{\beta}{\rk}}{\effmin} }
      { \tyju{\tyenv'}{\erun{p}} {\beta}{\effrun{\rk}} }
      %\\
      %\effeq{\effrun{\rk}}{\rk}
     %}
     %{
     %\tyju{\tyenv \tyconcat p : \rtproc{\beta}{\rk}}{\erun{p}} {\beta}{\rk}
     %}
%        \qquad \boxed{\rtvar = \rtproc{\beta}{\rk}}  
  }  
  { \tyju{\tyenv'}{\eproc{(\erun{p})}} 
                     {\rtproc{\beta}{ \effor{\effrun{\rk}}{\rk'} }}{\effmin} }
}
{ \tyju{\tyenv}{ \erec{p}{\eproc{(\erun{p})}} }{\rtproc{\beta}{\rk}}{\effmin} }
%\qquad \boxed{\rtvar = \rtproc{\beta}{\rk}}  
\]
%
where $\tyenv' = \tyenv \tyconcat p : \rtproc{\beta}{\rk}$.
The typing derivation shows that we must have \mbox{$\effor{\effrun{\rk}}{\rk'} = \rk$} to type this expression. The only behavior that verifies this equation is \mbox{$\rk = \effrec{\effvar}{\effor{\effrun{\effvar}}{\rk'}}$} ($\rk'$ is unconstrained here). Without $\mathtt{run}$, the typing derivation would be valid for any behavior $\rk$, for instance $\rk = \effmin$. It means that our analysis would have accepted this process even though it is obviously non-reactive. 

\item In~\cite{Mandel:2005}, the $\mathtt{loop}$ construct is encoded as a recursive process by:
%
\begin{align*}
\eloop{e} \deq &\mathid{run}(( \mathidl{rec} loop = 
     \elam{x}{ \\ &\qquad \eproc{(\eseq{\erun{x}}{\erun{(\eapp{loop}{x})}})}})\; (\eproc{e})) 
\end{align*}
%
By applying the rules here, we have that:
\[ loop: \forall \effvar.\, \rtarrow{\rtproc{\rtvar}{\effvar}}
                { \rtproc{\rtvar'}{\effrec{\effvar'}{\effcon{\effrun{\effvar}}{\effrun{\effvar'}}}}} \]
%

If we suppose that \mbox{$\tyju{\tyenv}{e}{\rt}{\rk}$}, then the behavior of this encoding is: 
  \[ \effrun{(\effrec{\effvar'}{\effcon{\effrun{\rk}}{\effrun{\effvar'}}})} \]
It is not equivalent to $\effinf{\rk}$ in the sense of Section~\ref{sec:equiv_behaviors}, but it is reactive iff $\effinf{\rk}$ is, as the $\mathtt{run}$ operator does not influence reactivity. It means that we could have removed $\mathtt{loop}$ from our kernel without any influence on the result of the reactivity analysis.

\item This is not the case of $\mathtt{pause}$ that can also be encoded by:
%
\begin{align*}
\mathtt{pause} \deq &\; \esig{s}{\evoid}{(\elam{x}{\elam{y}{\mathtt{\evoid}}})}
                                    { \\ &\qquad \epres{s}{\evoid}{\evoid}}
\end{align*}
%
We have chosen to completely abstract values. As in the `imprecise` example of Section~\ref{sec:intuition}, we do not consider the fact the signal $s$ is always absent, so that only the second branch of the $\mathtt{present}$ is executed. The consequence is that the behavior computed by the type system, that is, $\effeq{\effor{\effmin}{\effcon{\effplus}{\effmin}}}{\effmin}$, is the opposite of the correct behavior of $\epause$.

\end{itemize}

\subsection{Subeffecting with row polymorphism}
\label{sec:subeffecting_row}

\subsubsection*{Subeffecting}

The typing rule for the creation of processes intuitively mean that a process has \emph{at least} the behavior of its body. This subtyping restricted to effects is often referred to as \emph{subeffecting}~\cite{Nielson:1999}: we can always replace an effect with a bigger, i.e. less precise, one. It allows the type system to be a conservative extension of \rml{} type system, that is, we are able to give a behavior to any correct \rml{} program.

Subeffecting~\cite{Talpin:1992a,Nielson:1999} is usually expressed as a non-syntax directed rule (we reuse the same notations as in Section~\ref{sec:type_system} for better comparison):
%
\[
\inferrule
  { \tyju{\tyenv}{e}{\rt}{\rk} \\ \rk \sqsubseteq \rk' }
  { \tyju{\tyenv}{e}{\rt}{\rk'}  }
\]
%
The order $\sqsubseteq$ on effects is given by set inclusion when effects are sets (of regions for example). In our case, It is defined by:
\begin{mathpar}
\rk_1 \sqsubseteq \effor{\rk_1}{\rk_2}
\and
\rk_2 \sqsubseteq \effor{\rk_1}{\rk_2}
\and
\inferrule{ \effeq{\rk_1}{\rk_2} }{ \rk_1 \sqsubseteq \rk_2 }
\end{mathpar}

A similar approach is used in~\cite{Amtoft:1999}. It enforces effects to be \emph{simple}, that is, effects on arrows are syntactically forced to be variables. A constraint set is added to the type system to keep track of the relations between variables and effects. Subeffecting is then expressed as:
%
\[
\inferrule
  { \tyju{\tyenv, C}{e}{\rt}{\rk}   }
  {  \tyju{\tyenv, C \cup \{ \rk \sqsubseteq \effvar \} }{ \eproc{e} }{\rtproc{\rt}{\effvar}}{\effmin} }
\]

These three formulations appear to be equivalent. Indeed, our system and the one of~\cite{Amtoft:1999} are just syntax-directed versions of the first one, where the subtyping relation is applied only for lambda abstractions (or processes in our case).

\subsubsection*{Implementing subeffecting with row polymorphism}

The consequence of the typing rule for processes is that the principal type of an expression $\eproc{e}$ is always of the shape $\effor{\rk}{\effvar}$. The idea to use a free type variable to represent other possible types is reminiscent of Remy's row types~\cite{Remy:1993}. It makes it possible to implement subeffecting using only unification, without manipulating constraint sets as in traditional approaches~\cite{Talpin:1992a, Amtoft:1999}. This makes it easier to integrate it any existing ML type inference implementation. For instance, \ocaml{} type inference is also based on row polymorphism, so it would be easy to implement our analysis on top of the full language. 

During unification, the behavior of a process is always either a behavior variable~$\effvar$, a row~$\effor{\rk}{\effvar}$ or a recursive row~$\effrec{\effvar}{\effor{\rk}{\effvar'}}$. We could have made this fact more visible by having two different kinds of behaviors: behaviors and rows of behaviors. We chose here to stick with a more simple syntax. We can reuse any existing inference algorithm, like algorithm $\mW$ or $\mM$~\cite{Lee:1998a} and only use the following algorithm $\mU_{\rk}$ for unification of behaviors. It takes as input two behaviors and returns a substitution that maps behavior variables to behaviors, that we denote $[\effvar_1 \mapsto \rk_1; \effvar_2 \mapsto \rk_2; \dots]$. It is defined as follows:

\begin{small}
\begin{align*}
\mU_{\rk}(\rk, \rk) =&\, [] \\
\mU_{\rk}(\effvar, \rk) = \mU_{\rk}(\rk, \effvar) =
%					&\, [\effvar \mapsto  \effrec{\effvar'}{\rk[\effvar \leftarrow \effvar']} ]  \text{ if } \mathtt{occur\_check}(\effvar, \rk) \\
					&\, [\effvar \mapsto  \effrec{\effvar}{\rk} ]  \text{ if } \mathtt{occur\_check}(\effvar, \rk) \\
					= &\,  [\effvar \mapsto \rk] \\
\mU_{\rk}(\effor{\rk_1}{\effvar_1}, \effor{\rk_2}{\effvar_2}) =&\,
                  [\effvar_1 \mapsto \effor{\rk_2}{\effvar};  \effvar_1 \mapsto \effor{\rk_1}{\effvar} ]  \qquad \fresh{\effvar} \\
\mU_{\rk}(\effrec{\effvar'_1}{\effor{\rk_1}{\effvar_1}}, \rk_2) 
    = &\, \mU_{\rk}(\rk_2, \effrec{\effvar'_1}{\effor{\rk_1}{\effvar_1}}) \\ 
    = &\, \mlet K_1 = \effrec{\effvar'_1}{\effor{\rk_1}{\effvar_1}} \\
    &\, \mIn\, \mU_{\rk}( \effor{\rk_1[\effvar'_1 \leftarrow K_1]}{\effvar_1} , \rk_2) \\
%\mU_{\rk}(\effrec{\effvar'_1}{\effor{\rk_1}{\effvar_1}}, \effor{\rk_2}{\effvar_2} ) = 
%    &\, \mlet K_1 = \effrec{\effvar'_1}{\effor{\rk_1}{\effvar_1}} \\
%    &\, \mIn [ \effvar_1 \mapsto \effor{\rk_2}{\effvar} ;  \quad \fresh{\effvar} \\
%     & \quad\;\;                 \effvar_2 \mapsto \effor{\rk_1[\effvar'_1 \leftarrow K_1]}{\effvar}] \\
%\mU_{\rk}(\effrec{\effvar'_1}{\effor{\rk_1}{\effvar_1}}, 
%                 \effrec{\effvar'_2}{\effor{\rk_2}{\effvar_2}} ) = 
%         &\, \mlet K_1 = \effrec{\effvar'_1}{\effor{\rk_1}{\effvar_1}} \\
%         &\, \mand K_2 = \effrec{\effvar'_2}{\effor{\rk_2}{\effvar_2}} \\
%         &\, \mIn [   \effvar_1 \mapsto \effor{\rk_2[\effvar'_2 \leftarrow K_2]}{\effvar} ; 
%                                       \quad \fresh{\effvar} \\
%         & \quad\;\; \effvar_2 \mapsto \effor{\rk_1[\effvar'_1 \leftarrow K_1]}{\effvar} ] \\
%\mU_{\rk}(\rk_1, \rk_2) =&\, \fail{} \qquad\text{otherwise}
\end{align*}
\end{small}

\noindent It should be noted that unification never fails, so that we obtain a conservative extension of \rml type system. This unification algorithm also reuse traditional techniques for handling recursive types~\cite{Huet:1975}. The last case unfolds a recursive row to reveal the row variable, so that it can be unified with other rows. 

A downside of our approach is that it introduces one behavior variable for each process, so that the computed behaviors may get very big and unreadable. The purpose of the \textsc{Mask} rule is to remedy this, by using \emph{effect masking}~\cite{Lucassen:1988}. The idea is that if a behavior variable appearing in the behavior is free in the environment, it is not constrained so we can give it any value. In particular, we choose to replace it with $\effplus$, which is the neutral element of $+$, so that it can be simplified away.


\section{Proof of soundness}
\label{sec:soundness}

The intuition of the proof is that the first instant of a reactive behavior (as defined in Section~\ref{sec:reactive_behavior}) is a finite behavior, without any recursion. We then prove by induction on the size of behaviors that a well-typed process admits a finite derivation in the big-step semantics of Section~\ref{sec:semantics}.

\subsection{First instant of a behavior}

\begin{definition}
The \emph{first-instant behavior} of a behavior, denoted $\rkfst{\rk}$ is the part of the behavior that corresponds to the execution of the first instant of the corresponding process. It is formally defined by:
\begin{align*}
\rkfst{\effmin} =&\, \rkfst{\effplus}  = \effmin \\
\rkfst{\effvar} =&\, \effvar \\
\rkfst{\effrun{\rk}} =&\, \effrun{(\rkfst{\rk})} \\ 
\rkfst{\effpar{\rk_1}{\rk_2}} =&\, \effpar{\rkfst{\rk_1}}{\rkfst{\rk_2}} \\
\rkfst{\effor{\rk_1}{\rk_2}} =&\, \effor{\rkfst{\rk_1}}{\rkfst{\rk_2}} \\
\rkfst{\effcon{\rk_1}{\rk_2}} =&\, 
		\left\{ \begin{array}{ll}  
				\rkfst{\rk_1} & \text{if } \noinst{\rk_1} \\
				\effcon{\rkfst{\rk_1}}{\rkfst{\rk_2}} &\text{otherwise} 
		\end{array}\right. \\
\rkfst{\effrec{\effvar}{\rk}} =&\, \rkfst{\rk[\effvar \leftarrow \effrec{\effvar}{\rk}]}
\end{align*}
\end{definition}
In the case of a recursive behavior,  the first-instant behavior is well-defined only if the behavior is reactive, that is, the recursion is not instantaneous.

\todo{Ne le definir que pour comportement ferme ?}
\begin{definition}
A behavior is \emph{finite}, denoted $\rkfinite{\rk}$, if it does not contain any true recursive behavior. Formally, the predicate is defined by:
\begin{mathpar}
\inferrule{ }{\rkfinite{\effmin}}
\and
\inferrule{ }{\rkfinite{\effplus}}
\and
\inferrule{ }{\rkfinite{\effvar}}
\and
\inferrule{ \rkfinite{\rk_1} \\ \rkfinite{\rk_2} }{ \rkfinite{\effpar{\rk_1}{\rk_2}}  }
\and
\inferrule{ \rkfinite{\rk_1} \\ \rkfinite{\rk_2} }{ \rkfinite{\effor{\rk_1}{\rk_2}}  }
\and
\inferrule{ \rkfinite{\rk_1} \\ \rkfinite{\rk_2} }{ \rkfinite{\effcon{\rk_1}{\rk_2}}  }
\and
\inferrule{ \rkfinite{\rk} \\ \effvar \not\in fbv(\rk) }{ \rkfinite{\effrec{\effvar}{\rk} } }
\and
\inferrule{ \rkfinite{\rk} }{ \rkfinite{\effrun{\rk} } }
\end{mathpar}
\end{definition}

\begin{property}
If $\rk$ is reactive, then $\rkfst{\rk}$ is a finite behavior, i.e.:
\[ \wf{\emptyset}{\rk} \Rightarrow \rkfinite{\rkfst{\rk}} \]
\end{property}

\subsection{Soundness}

As we said earlier, we do not try to prove that functions terminate and only care about processes. We suppose that all functions terminate, which is reflected in the rule for application (Figure~\ref{fig:rules}) by the fact that the behavior of the application is always the instantaneous behavior $\effmin$. This hypothesis is made possible by the syntactic distinction between functions and processes. Before going further with the proof of soundness, we have to express this hypothesis more formally with respect to the big-step semantics.

\begin{hypothesis}[Function calls always terminate]
\label{hyp:fun_terminate} 
Formally, for any ML expression $e$ such that $0 \vdash e$, there exists a finite derivation $\Pi_e$ and a value $v$ such that:
\[ \inferrule{\Pi_e}{ \quad \bigstep{N}{e}{v} {E}{b}{S} \quad } \] 
\end{hypothesis}

\begin{lemma}
\label{lem:noinst}
If $ \bigstep{N}{e}{e'} {E}{b}{S}$ and $\tyju{\tyenv}{e}{\rt}{\rk}$ then 
   \[ \noinst{\rk} \Rightarrow b = \sfalse \]
\end{lemma}
\begin{proof}
By induction on the derivation of the big-step semantics.
\end{proof}

We can now express the soundness of our analysis, that is, a well-typed program is reactive. Being reactive means here that there exists a derivation, necessarily finite, to rewrite the program into a well-typed program.
\begin{theorem}[Soundness]
\label{thm:soundness}
If \mbox{$\tyju{\tyenv}{e}{\rt}{\rk}$} and $\rt$ and $\rk$ are reactive and we suppose that function calls terminate, then there exists $e'$ such that \mbox{$\bigstep{N}{e}{e'} {E}{b}{S}$} and \mbox{$\tyju{\tyenv}{e'}{\rt}{\rk'}$} with $\rk'$ reactive.
\end{theorem}
\begin{proof}
The proof is done by induction on the size of the first-instant behavior of well-typed expressions. The main point is that the behaviors of sub-expressions is always smaller, but we have to be careful that we must consider only the first-instant behavior. To prove that the result is well-typed, we can use classic syntactic techniques for type soundness~\cite{Pierce:2002} on the small-step semantics described in~\cite{Mandel:2005}. The proof of equivalence of the two semantics is also given in the same paper.
%
\todo{Corriger les notations dans les regles et ici pour les accorder}
\begin{itemize}
\item Case $\eapp{e_1}{e_2}$ and $\erec{x}{e}$: By hypothesis~\ref{hyp:fun_terminate}.

\item Case $\erun{e}$: We know that $0 \vdash e$ so there exists $\Pi$ such that 
\[ \inferrule{\Pi}{ \bigstep{N_1}{e}{\eproc{e_1}} {E}{true}{S} } \]
Then, as $\erun{e}$ is well-typed, we have that:
\[
\inferrule
  {
  \inferrule
    { \tyju{\tyenv}{e_1} {\rt}{\rk}  }
    { \tyju{\tyenv}{\eproc{e_1}} { \rtproc{\rt}{\effor{\rk}{\rk'}} }{\effmin} }
  }
  { \tyju{\tyenv}{\erun{(\eproc{e_1})}} {\rt}{\effrun{(\effor{\rk}{\rk'})}} }
\]
As \mbox{$\rkfst{\effrun{(\effor{\rk}{\rk'})}} = \effor{\effrun{(\rkfst{\rk})}}{\effrun{(\rkfst{\rk'})}}$}, we can apply the induction hypothesis on $e_1$ to get:
\[  \inferrule{\Pi_1}{ \bigstep{N_2}{e_1}{e'_1} {E_1}{b}{S} } \]
which enables us to build the complete derivation of $\erun{e}$:
\[
\inferrule
{
\inferrule{\Pi}{ \bigstep{N_1}{e}{\eproc{e_1}} {E}{true}{S} } \\
\inferrule{\Pi_1}{ \bigstep{N_2}{e_1}{e'_1} {E_1}{b}{S} }
}
{ \bigstep{N_1 \cdotp N_2}{\erun{e}}{e'_1} {E \sqcup E_1}{b}{S} }
\]

\item Case $\epause{}$: The derivation is already finite without any hypothesis.

\item Case $\epres{e}{e_1}{e_2}$: 
Like in the first case, we have:
\[ \inferrule{\Pi}{ \bigstep{N_1}{e}{n} {E}{true}{S} } \]
The typing rule is as follows:
\[ 
\inferrule%[Present]
  { \tyju{\tyenv}{e}{\rtsig{\rt_1}{\rt_2}}{\effmin} \\
    \tyju{\tyenv}{e_1}{\rt}{\rk_1}  \\
    \tyju{\tyenv}{e_2}{\rt}{\rk_2}  }
  { \tyju{\tyenv} { \epres{e}{e_1}{e_2} }{\rt}{ \effor{\rk_1}{(\effcon{\effplus}{\rk_2})} } }
\]
The are then two cases depending on the status of $n$:
\begin{itemize}
\item If \mbox{$n \in S$}: We can notice that \[ \rkfst{\effor{\rk_1}{(\effcon{\effplus}{\rk_2})}} = \effor{\rkfst{\rk_1}}{\effmin} \] so we can apply the induction hypothesis on $e_1$ and conclude. 
\item If $n \not\in S$: The derivation is finite.
\end{itemize}

\item Case $\ewhen{e_1}{e_2}$: We can use the same reasoning. It is interesting to note that the behavior associated to the expression, i.e. $\effor{\rk}{\effinf{\effplus}}$, is not equal to the behavior of the body, as one could expect, so that we can apply the induction hypothesis.

\item Case $\eletpar{x_1}{e_1}{x_2}{e_2}{e}$:
When we compute the first instant of a sequence, there are two possible cases:
\begin{itemize}
\item If $\noinst{(\effpar{\rk_1}{\rk_2})}$, then we have that 
\[  \rkfst{\rk} = \effpar{\rkfst{\rk_1}}{\rkfst{\rk_2}} \]
From $\noinst{(\effpar{\rk_1}{\rk_2})}$, we get that either $\noinst{\rk_1}$ which implies that $b_1 = \sfalse$, or $\noinst{\rk_2}$ which implies that $b_2 = \sfalse$ using Lemma~\ref{lem:noinst}. So we are sure that $b_1 \land b_2 = \sfalse$. We can then apply the induction hypothesis on $e_1$ and $e_2$ using the rule~\textsc{Let-Par}.

\item Otherwise, we have that
\[  \rkfst{\rk} = \effcon{(\effpar{\rkfst{\rk_1}}{\rkfst{\rk_2}})}{\rkfst{\rk}} \]
We can apply the induction hypothesis on $e_1$, $e_2$ and $e$ using either \textsc{Let-par} or \textsc{Let-Done} depending on the values of $b_1$ and $b_2$.
\end{itemize}

\item Case $\eloop{e_1}$: 
We have that $\rkfst{(\effcon{\effmin}{\rk})} = \effcon{\effmin}{\rkfst{\rk}}$, so we can apply the induction hypothesis on $e_1$.
As the behavior $\effinf{(\effcon{\effmin}{\rk})}$ is reactive, we know that $\noinst{\rk}$. By applying Lemma~\ref{lem:noinst}, we get that $b_1 = \sfalse$, so we reconstruct the complete derivation for $e$ using the \textsc{Loop-Stuck} rule.

\end{itemize}

\end{proof}

\section{Discussion}
\label{sec:discussion}

\subsection{Simplifying behaviors}

The behaviors computed by the type system of Section~\ref{sec:type_system} are very big. For instance, the behavior associated to the `timer` example is 
\[ \effinf{(\effcon{(\effpar{\effmin}{\effmin})}{(\effor{\effmin}{(\effcon{\effmin}{\effmin})})})} \] 
This behavior is unnecessarily detailed and almost as big (if not bigger) than the source program. However, we can notice that this behavior is equivalent to $\effinf{\effmin}$.

We would like to use this equivalence relation on behaviors defined in Section~\ref{sec:equiv_behaviors} in our type system to reduce the size of the computed behaviors. We must  make sure that this does not break the proof of soundness of Section~\ref{sec:soundness}. This is ensured by the fact that the equivalence relation preserves reactivity, which is the only condition requested by the proof.

We can thus define a variant of the type system, with a new typing judgment $\tyjus{\tyenv}{e}{\rt}{\rk}$. It is defined by the rules given in Figure~\ref{fig:rules} with one additional rule, that allows to simplify behaviors at any time using the equivalence relation:
\[
\rulename{Equiv}
\inferrule
  { \tyjus{\tyenv}{e}{\rt}{\rk_1} \\ \effeq{\rk_1}{\rk_2} }
  { \tyjus{\tyenv}{e}{\rt}{\rk_2} } 
\]
We cannot add this rule to the original system as the proof of soundness relies on the fact that the behavior of sub-expressions is always smaller, which is no longer the case once we allow simplifications. We can also simplify some rules, by combining the original rule with the \textsc{Equiv} rule:
\begin{mathpar}
%
\inferrule%*[Left=(Signal)]
  { \tyjus{\tyenv}{e_1}{\rt_2}{\effmin}  \\ 
    \tyjus{\tyenv}{e_2}{ \rtarrow{\rt_1}{\rtarrow{\rt_2}{\rt_2}} }{\effmin} \\\\
    \tyjus{\tyenv \tyconcat x : \rtsig{\rt_1}{\rt_2}} {e} {\rt}{\rk}  }
  { \tyjus{\tyenv}{ \esig{x}{e_1}{e_2}{e} } {\rt}{ \rk} }
%
\and
%
\inferrule%[When]
  { \tyjus{\tyenv}{e_1}{\rt}{\rk} \\\\
    \tyjus{\tyenv}{e_2}{\rtsig{\rt_1}{\rt_2}}{\effmin} }
  { \tyjus{\tyenv}{ \ewhen{e_1}{e_2} } {\rt} {\rk} } 
%
\and
%
\inferrule%[Loop]
  { \tyju{\tyenv}{e}{\rt}{\rk} }
  { \tyju{\tyenv}{\eloop{e}}{\unit}{\effinf{\rk}} }
%
\end{mathpar}

The \textsc{Equiv} rule does not change the fact that a program is accepted or rejected by the type system. It only allows to reduce the size of computed behaviors:
\begin{property}
\label{prop:variant_system}
If $\tyjus{\tyenv}{e}{\rt}{\rk}$, then $\tyju{\tyenv}{e}{\rt'}{\rk'}$ with $\effeq{\rk}{\rk'}$ and $\tyeq{\rt}{\rt'}$.
\end{property}
\begin{proof}
Straightforward by induction on the typing rules
\end{proof}

We can then express the soundness theorem in terms of the variant of the type system:
\begin{theorem}[Soundness (variant)]
If \mbox{$\tyjus{\tyenv}{e}{\rt}{\rk}$} and $\rt$ and $\rk$ are reactive and we suppose that function calls terminate, then there exists $e'$ such that \mbox{$\bigstep{N}{e}{e'} {E}{b}{S}$} and \mbox{$\tyjus{\tyenv}{e'}{\rt}{\rk'}$} with $\rk'$ reactive.
\end{theorem}
\begin{proof}
By applying Property~\ref{prop:variant_system}, Property~\ref{prop:equiv_reactivty} and Theorem~\ref{thm:soundness}.
\end{proof}

\subsection{Examples}

The behavior computed for the `timer` example of Section~\ref{sec:first_example} is \mbox{$\effinf{(\effcon{(\effpar{\effmin}{\effmin})}{(\effor{\effmin}{(\effcon{\effmin}{\effmin})})})}$}, which is equivalent to $\effinf{\effmin}$ and not reactive. After the fix, the behavior becomes \mbox{$\effinf{(\effcon{(\effpar{\effmin}{\effmin})}{\effcon{(\effor{\effmin}{(\effcon{\effmin}{\effmin})})}{\effplus}})}$} (equivalent to $\effinf{\effplus}$), which is now reactive. Similarly, the `instantaneous` process defined in Section~\ref{sec:intuition} has a behavior equal to $\effrec{\effvar}{\effcon{\effmin}{\effrun{\effvar}}}$, that is obviously non reactive.

Using a type-based analysis makes it easy to deal with cases of aliasing, like in the following example:
\begin{lstlisting}
let rec process p =
  let q = (fun x -> x) p in
  run q 
?val p : 'a process[(rec 'r. run 'r) + ..]?
?W: This expression may produce an instantaneous recursion?
\end{lstlisting}
As for objects in \ocaml~\cite{Vouillon:2008}, row variables that appear only once are printed \verb+`..'+.
%
The analysis can also handle combinators. In that case, there is no warning when defining the combinator if it is not possible to decide of its reactivity:
\begin{lstlisting}
let process par_comb q1 q2 =
  loop
    run q1 || run q2
  end
?val par_comb : 'a process['r1] -> 'b process ['r2] ->
  unit process[(rec 'r3. run 'r1 || run 'r2 ;  'r3) + ..]?
\end{lstlisting}
%
This is reflected formally by the fact that free behavior variables are considered to be non-instantaneous (see Section~\ref{sec:reactive_behavior}). The reactivity is then checked at instantiation:
\begin{lstlisting}
let process p1 = 
  run (par_comb (process ()) (process (pause)))
?val p1 : unit process[(rec 'r. run 0 || run *; 'r) + ..]?

let process p2 = 
  run (par_comb (process ()) (process ()))
?val p2 : unit process[(rec 'r. run 0 || run 0; 'r) + ..]
W: This expression may produce an instantaneous recursion?
\end{lstlisting}

Here is another more complex example using higher-order functions and processes:
\begin{lstlisting}
let h_o f =
 let rec process p =
   let q = f p in
   run q
 in p
?val h_o : ('a process[run 'r1 + 'r2] -> 'a process['r1]) 
                -> 'a process[run 'r1 + 'r2]?

let process good = 
  run (higher_order 
         (fun x -> process (pause; run x)))
?val good :
 'a process[run (run ((rec 'r1. *; run (run 'r1)) + ..))]?

let process pb = 
  run (higher_order (fun x -> process (run x)))
?val pb :
  'a process[run (run ((rec 'r1. run (run 'r1)) + ..))]
W: This expression may produce an instantaneous recursion?
\end{lstlisting}

Another interesting process that is rejected by our analysis is a fixpoint operator. It takes as input a function expecting a continuation, and applies it with itself as the continuation. This fixpoint operator can be used to create a recursive process, which reactivity is checked by our analysis:
\begin{lstlisting}
let rec fix f x = f (fix f) x
?val fix : (('a -> 'b) -> 'a -> 'b) -> 'a -> 'b?

let process main =
  let process p k v =
    print_int v; print_newline (); 
    run (k (v+1))
  in
  run (fix p 0)
?val main : 'a process[(run (rec 'r. run 'r)) + ..]
W: This expression may produce an instantaneous recursion?
\end{lstlisting}

\subsection{Adding references}

References are not included in the kernel of our language. However, they are relevant to the matter as they can be used to encode recursivity, as in the following example that creates a process that loops instantaneously:
%
\begin{lstlisting}
let landin () =
  let f = ref (process ()) in
  f := process (run !f);
  !f
?val landin : unit -> 
        unit process[0 + (rec 'r1. run (0 + 'r1)) + ..]?
?W: This expression may produce an instantaneous recursion?
\end{lstlisting}
%
%?val landin : unit -> 
%        unit process[$\effor{\effor{\effmin}{\effrec{\effvar
%                         }{\effrun{(\effor{\effmin}{\effvar})}}}}{\effvar'}$] ?
As our analysis does not have any special case for recursive processes and is only based on unification, it is able to detect the reactivity issue even though there is no explicit recursion.

\subsection{Implementation}

The type inference algorithm of \rml has been extended to compute the behaviors of processes, with a small impact on its structure and complexity thanks to the use of row polymorphism for subeffecting (see Section~\ref{sec:subeffecting_row}). The rules given in Section~\ref{sec:reactive_behavior} are easily translated into an algorithm for checking the reactivity of behaviors, polynomial in the size of behaviors. Inference simplifies behaviors during the computation, but does not necessarily compute the smallest behavior possible. For instance, simplifying $\effor{\rk}{\rk}$ can be costly in some cases, so it only checks simple cases (e.g. if $\rk = \effmin$ or $\rk = \effplus$). Overall, the analysis has a small impact on the compilation time of \rml programs.

\section{Related work}
\label{sec:related_work}

Reactivity analysis is a classic topic in synchronous languages, also referred to as \emph{causality} analysis. In \esterel~\cite{Berry:1997}, the first imperative synchronous language, reactivity can be checked easily as the language is first order without recursion. Closer to \rml, the reactivity analysis of \funloft~\cite{Amadio:2007b} not only checks that instants terminate, but also give a bound on the duration of the instants trough a value analysis. The analysis is also restricted to the first-order setting. In \ulm~\cite{Boudol:2004}, each recursive call induces an implicit pause. Hence, it is impossible to have instantaneous recursions, at the expense of expressivity. For instance, in the `server` example of Section~\ref{sec:intuition}, a message could be lost between receiving a message on `add` and awaiting a new message.

The causality analysis of \lucy~\cite{Cuoq:2001} is a type-and-effect system using row types. It is based on the exception analysis done in~\cite{Leroy:2000}. Both are a more direct application of row types~\cite{Remy:1993}, whereas our system differs in the absence of labels in rows.


Our language of behaviors and type system is inspired by the work of~\cite{Amtoft:1999}. Their analysis is done on the \cml~\cite{Reppy:2007} language, which extends ML with message passing primitives. The behavior of a process records every emission and reception on communication channels. The authors use the type system to prove properties on particular examples, not for a general analysis. For instance, they prove that the emission on a given channel always precede the emission on a second channel in a given program. \cite{Boudol:2010}~uses a type-and-effect system to prove termination of functional programs using references, by stratifying memory to avoid recursion through references.


\section{Conclusion}

Future work: meta-theory of type system (principality, etc). Comparison with other subeffecting formulations

\bibliographystyle{plain}

\begin{small}
\bibliography{biblio}
\end{small}

\clearpage

\begin{figure*}[t]
%\begin{small}
\input{big_step_other}
%\end{small}

\caption{Remaining rules for the big-step semantics}
\label{fig:big_step_other}
\end{figure*}



\appendix

\section{The complete big-step semantics}
\label{sec:big_step_other}

\todo{mettre les règles exactes de définition de l'environnement de signal et des règeles de reaction telles que dans \cite{Mandel:2005}}

See Figure~\ref{fig:big_step_other}.

\end{document}
